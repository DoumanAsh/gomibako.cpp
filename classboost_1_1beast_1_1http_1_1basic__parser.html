<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ゴミ箱: boost::beast::http::basic_parser&lt; isRequest, Derived &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ゴミ箱
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast.html">beast</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast_1_1http.html">http</a></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classboost_1_1beast_1_1http_1_1basic__parser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::http::basic_parser&lt; isRequest, Derived &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="basic__parser_8hpp_source.html">basic_parser.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::beast::http::basic_parser&lt; isRequest, Derived &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1http_1_1basic__parser.png" usemap="#boost::beast::http::basic_5Fparser_3C_20isRequest_2C_20Derived_20_3E_map" alt=""/>
  <map id="boost::beast::http::basic_5Fparser_3C_20isRequest_2C_20Derived_20_3E_map" name="boost::beast::http::basic_parser&lt; isRequest, Derived &gt;_map">
<area href="classboost_1_1beast_1_1http_1_1detail_1_1basic__parser__base.html" alt="boost::beast::http::detail::basic_parser_base" shape="rect" coords="0,0,315,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a05ada24f1fd4e5e5107c01fbcb8682d8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a05ada24f1fd4e5e5107c01fbcb8682d8">is_request</a> = std::integral_constant&lt; bool, isRequest &gt;</td></tr>
<tr class="memdesc:a05ada24f1fd4e5e5107c01fbcb8682d8"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>true</code> if this parser parses requests, <code>false</code> for responses.  <a href="#a05ada24f1fd4e5e5107c01fbcb8682d8">More...</a><br /></td></tr>
<tr class="separator:a05ada24f1fd4e5e5107c01fbcb8682d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a792ba414ec3779a1032e2bc508fbb8ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a792ba414ec3779a1032e2bc508fbb8ed">~basic_parser</a> ()</td></tr>
<tr class="memdesc:a792ba414ec3779a1032e2bc508fbb8ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a792ba414ec3779a1032e2bc508fbb8ed">More...</a><br /></td></tr>
<tr class="separator:a792ba414ec3779a1032e2bc508fbb8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb65c21085d124b1a2a756ee9bb4ee9c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#adb65c21085d124b1a2a756ee9bb4ee9c">basic_parser</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const &amp;)=delete</td></tr>
<tr class="memdesc:adb65c21085d124b1a2a756ee9bb4ee9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#adb65c21085d124b1a2a756ee9bb4ee9c">More...</a><br /></td></tr>
<tr class="separator:adb65c21085d124b1a2a756ee9bb4ee9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fcc94b6bae7e8617c4525e2c290e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac9fcc94b6bae7e8617c4525e2c290e57">operator=</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const &amp;)=delete</td></tr>
<tr class="memdesc:ac9fcc94b6bae7e8617c4525e2c290e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ac9fcc94b6bae7e8617c4525e2c290e57">More...</a><br /></td></tr>
<tr class="separator:ac9fcc94b6bae7e8617c4525e2c290e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618a53dff6b57e2911e2cc546c8e3218"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a618a53dff6b57e2911e2cc546c8e3218">basic_parser</a> ()</td></tr>
<tr class="memdesc:a618a53dff6b57e2911e2cc546c8e3218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#a618a53dff6b57e2911e2cc546c8e3218">More...</a><br /></td></tr>
<tr class="separator:a618a53dff6b57e2911e2cc546c8e3218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6115f87044acb0e9a7baba5858fd6c87"><td class="memTemplParams" colspan="2">template&lt;class OtherDerived &gt; </td></tr>
<tr class="memitem:a6115f87044acb0e9a7baba5858fd6c87"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a6115f87044acb0e9a7baba5858fd6c87">basic_parser</a> (<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&lt; isRequest, OtherDerived &gt; &amp;&amp;)</td></tr>
<tr class="separator:a6115f87044acb0e9a7baba5858fd6c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93520ef1f14748d347cb1aafab7a0a85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a93520ef1f14748d347cb1aafab7a0a85">base</a> ()</td></tr>
<tr class="separator:a93520ef1f14748d347cb1aafab7a0a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11ccc12eb006f4a5efa795d2c7107e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ad11ccc12eb006f4a5efa795d2c7107e6">base</a> () const </td></tr>
<tr class="separator:ad11ccc12eb006f4a5efa795d2c7107e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf271f94c1fc15867eafb78cbcbaf729"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#acf271f94c1fc15867eafb78cbcbaf729">got_some</a> () const </td></tr>
<tr class="memdesc:acf271f94c1fc15867eafb78cbcbaf729"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the parser has received at least one byte of input.  <a href="#acf271f94c1fc15867eafb78cbcbaf729">More...</a><br /></td></tr>
<tr class="separator:acf271f94c1fc15867eafb78cbcbaf729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2353d732aa20fe50b548bb1da1c7f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a3a2353d732aa20fe50b548bb1da1c7f3">is_done</a> () const </td></tr>
<tr class="separator:a3a2353d732aa20fe50b548bb1da1c7f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2c565b37b248565113777047b8bd43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abe2c565b37b248565113777047b8bd43">is_header_done</a> () const </td></tr>
<tr class="separator:abe2c565b37b248565113777047b8bd43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c754688183e96e3bf73ca0ef8a32ee1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a7c754688183e96e3bf73ca0ef8a32ee1">is_upgrade</a> () const </td></tr>
<tr class="separator:a7c754688183e96e3bf73ca0ef8a32ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fa1a4c5410f6d8b4512bc3e6628c62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a35fa1a4c5410f6d8b4512bc3e6628c62">is_chunked</a> () const </td></tr>
<tr class="separator:a35fa1a4c5410f6d8b4512bc3e6628c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ead94986d3d82ab9df5c348d33c204"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a18ead94986d3d82ab9df5c348d33c204">is_keep_alive</a> () const </td></tr>
<tr class="separator:a18ead94986d3d82ab9df5c348d33c204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db439b14f50f4898e7f7268fc9f37d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4ad57c24f3fe52d16e7169b912dd647f0d">boost::optional</a>&lt; std::uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a6db439b14f50f4898e7f7268fc9f37d8">content_length</a> () const </td></tr>
<tr class="separator:a6db439b14f50f4898e7f7268fc9f37d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfec7ffb8a2bc8e5adec883acda5d2fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#acfec7ffb8a2bc8e5adec883acda5d2fc">need_eof</a> () const </td></tr>
<tr class="separator:acfec7ffb8a2bc8e5adec883acda5d2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e7c6629c9d91f0010160ff37831fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a74e7c6629c9d91f0010160ff37831fb1">body_limit</a> (std::uint64_t v)</td></tr>
<tr class="separator:a74e7c6629c9d91f0010160ff37831fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315563999dc446bab4ee2d0d3bebbc5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a315563999dc446bab4ee2d0d3bebbc5e">header_limit</a> (std::uint32_t v)</td></tr>
<tr class="separator:a315563999dc446bab4ee2d0d3bebbc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae9e9bb5767f7b487faca7a42d8e651"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aaae9e9bb5767f7b487faca7a42d8e651">eager</a> () const </td></tr>
<tr class="memdesc:aaae9e9bb5767f7b487faca7a42d8e651"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the eager parse option is set.  <a href="#aaae9e9bb5767f7b487faca7a42d8e651">More...</a><br /></td></tr>
<tr class="separator:aaae9e9bb5767f7b487faca7a42d8e651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ed7a48af0693ae501648917c0b518b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a70ed7a48af0693ae501648917c0b518b">eager</a> (bool v)</td></tr>
<tr class="separator:a70ed7a48af0693ae501648917c0b518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af888129a2e1a589fff926fbca3f2712a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#af888129a2e1a589fff926fbca3f2712a">skip</a> ()</td></tr>
<tr class="memdesc:af888129a2e1a589fff926fbca3f2712a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the skip parse option is set.  <a href="#af888129a2e1a589fff926fbca3f2712a">More...</a><br /></td></tr>
<tr class="separator:af888129a2e1a589fff926fbca3f2712a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb614d7566c2d0d7e69c572c80c0fcc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a2cb614d7566c2d0d7e69c572c80c0fcc">skip</a> (bool v)</td></tr>
<tr class="separator:a2cb614d7566c2d0d7e69c572c80c0fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7687744e64f99637505a762643d4717"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:aa7687744e64f99637505a762643d4717"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa7687744e64f99637505a762643d4717">put</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:aa7687744e64f99637505a762643d4717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac199c018acbc29b034a59e671ff604d0"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ac199c018acbc29b034a59e671ff604d0">put</a> (boost::asio::const_buffers_1 const &amp;buffer, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac199c018acbc29b034a59e671ff604d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad057df8cd62394aa7072771759492a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ad057df8cd62394aa7072771759492a7a">put_eof</a> (<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ad057df8cd62394aa7072771759492a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af80fd5cd05d172059580176004255d23"><td class="memTemplParams" colspan="2">template&lt;bool OtherIsRequest, class OtherDerived &gt; </td></tr>
<tr class="memitem:af80fd5cd05d172059580176004255d23"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#af80fd5cd05d172059580176004255d23">basic_parser</a></td></tr>
<tr class="separator:af80fd5cd05d172059580176004255d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;bool isRequest, class Derived&gt;<br />
class boost::beast::http::basic_parser&lt; isRequest, Derived &gt;</h3>

<p>A parser for decoding HTTP/1 wire format messages.</p>
<p>This parser is designed to efficiently parse messages in the HTTP/1 wire format. It allocates no memory when input is presented as a single contiguous buffer, and uses minimal state. It will handle chunked encoding and it understands the semantics of the Connection, Content-Length, and Upgrade fields. The parser is optimized for the case where the input buffer sequence consists of a single contiguous buffer. The <a class="el" href="namespaceboost_1_1beast.html#a1647e26a51ca128f374bdb1b4438acf5">flat_buffer</a> class is provided, which guarantees that the input sequence of the stream buffer will be represented by exactly one contiguous buffer. To ensure the optimum performance of the parser, use <a class="el" href="namespaceboost_1_1beast.html#a1647e26a51ca128f374bdb1b4438acf5">flat_buffer</a> with HTTP algorithms such as <a class="el" href="namespaceboost_1_1beast_1_1http.html#aa5227496e49d45c3448cac05357d0d68">read</a>, <a class="el" href="namespaceboost_1_1beast_1_1http.html#aa64d4b1494ef161d2b159216bfee3482">read_some</a>, <a class="el" href="namespaceboost_1_1beast_1_1http.html#a8f3a847ccae9e273d082a956e3dca73d">async_read</a>, and <a class="el" href="namespaceboost_1_1beast_1_1http.html#aa9900ab5481eb09b3b0a8e8e5dd90b5a">async_read_some</a>. Alternatively, the caller may use custom techniques to ensure that the structured portion of the HTTP message (header or chunk header) is contained in a linear buffer.</p>
<p>The interface uses CRTP (Curiously Recurring Template Pattern). To use this class directly, derive from <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>. When bytes are presented, the implementation will make a series of zero or more calls to derived class members functions (termed "callbacks" in this context) matching a specific signature.</p>
<p>Every callback must be provided by the derived class, or else a compilation error will be generated. This exemplar shows the signature and description of the callbacks required in the derived class. For each callback, the function will ensure that <code>!ec</code> is <code>true</code> if there was no error or set to the appropriate error code if there was one. If an error is set, the value is propagated to the caller of the parser.</p>
<dl class="section user"><dt>Derived Class Requirements</dt><dd><div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> isRequest&gt;</div><div class="line"><span class="keyword">class </span>derived</div><div class="line">    : <span class="keyword">public</span> <a class="code" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a618a53dff6b57e2911e2cc546c8e3218">basic_parser</a>&lt;isRequest, derived&lt;isRequest&gt;&gt;</div><div class="line">{</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="comment">// The friend declaration is needed,</span></div><div class="line">    <span class="comment">// otherwise the callbacks must be made public.</span></div><div class="line">    <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a618a53dff6b57e2911e2cc546c8e3218">basic_parser</a>&lt;isRequest, derived&gt;;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_request_impl(</div><div class="line">        <a class="code" href="namespaceboost_1_1beast_1_1http.html#a817a25f3da653b784f541ae293a84348">verb</a> method,                <span class="comment">// The method verb, verb::unknown if no match</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> method_str,     <span class="comment">// The method as a string</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target,         <span class="comment">// The request-target</span></div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4a2af72f100c356273d46284f6fd1dfc08">version</a>,                <span class="comment">// The HTTP-version</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_response_impl(</div><div class="line">        <span class="keywordtype">int</span> code,                   <span class="comment">// The status-code</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> reason,         <span class="comment">// The obsolete reason-phrase</span></div><div class="line">        <span class="keywordtype">int</span> <a class="code" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4a2af72f100c356273d46284f6fd1dfc08">version</a>,                <span class="comment">// The HTTP-version</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_field_impl(</div><div class="line">        <a class="code" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4">field</a> f,                    <span class="comment">// The known-field enumeration constant</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> name,           <span class="comment">// The field name string.</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> value,          <span class="comment">// The field value</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_header_impl(</div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_body_init_impl(</div><div class="line">        <a class="code" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4ad57c24f3fe52d16e7169b912dd647f0d">boost::optional</a>&lt;</div><div class="line">            std::uint64_t&gt; <span class="keyword">const</span>&amp;</div><div class="line">                <a class="code" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a6db439b14f50f4898e7f7268fc9f37d8">content_length</a>,     <span class="comment">// Content length if known, else `boost::none`</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    std::size_t</div><div class="line">    on_body_impl(</div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> s,              <span class="comment">// A portion of the body</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_chunk_header_impl(</div><div class="line">        std::uint64_t size,         <span class="comment">// The size of the upcoming chunk,</span></div><div class="line">                                    <span class="comment">// or zero for the last chunk</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> extension,      <span class="comment">// The chunk extensions (may be empty)</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    std::size_t</div><div class="line">    on_chunk_body_impl(</div><div class="line">        std::uint64_t remain,       <span class="comment">// The number of bytes remaining in the chunk,</span></div><div class="line">                                    <span class="comment">// including what is being passed here.</span></div><div class="line">                                    <span class="comment">// or zero for the last chunk</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> body,           <span class="comment">// The next piece of the chunk body</span></div><div class="line">        <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);            <span class="comment">// The error returned to the caller, if any</span></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span></div><div class="line">    on_finish_impl(<a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>&amp; ec);</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    derived() = <span class="keywordflow">default</span>;</div><div class="line">};</div></div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">isRequest</td><td>A <code>bool</code> indicating whether the parser will be presented with request or response message.</td></tr>
    <tr><td class="paramname">Derived</td><td>The derived class type. This is part of the Curiously Recurring Template Pattern interface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the parser encounters a field value with obs-fold longer than 4 kilobytes in length, an error is generated. </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a05ada24f1fd4e5e5107c01fbcb8682d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#a05ada24f1fd4e5e5107c01fbcb8682d8">is_request</a> =  std::integral_constant&lt;bool, isRequest&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code>true</code> if this parser parses requests, <code>false</code> for responses. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a792ba414ec3779a1032e2bc508fbb8ed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::~<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="adb65c21085d124b1a2a756ee9bb4ee9c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&lt; isRequest, Derived &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a618a53dff6b57e2911e2cc546c8e3218"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="a6115f87044acb0e9a7baba5858fd6c87"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
<div class="memtemplate">
template&lt;class OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::<a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&lt; isRequest, OtherDerived &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor</p>
<p>After the move, the only valid operation on the moved-from object is destruction. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a93520ef1f14748d347cb1aafab7a0a85"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&amp; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to this object as a <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>.</p>
<p>This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. </p>

</div>
</div>
<a class="anchor" id="ad11ccc12eb006f4a5efa795d2c7107e6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a> const&amp; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::base </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a constant reference to this object as a <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>.</p>
<p>This is used to pass a derived class where a base class is expected, to choose a correct function overload when the resolution would be ambiguous. </p>

</div>
</div>
<a class="anchor" id="a74e7c6629c9d91f0010160ff37831fb1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::body_limit </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the limit on the payload body.</p>
<p>This function sets the maximum allowed size of the payload body, before any encodings except chunked have been removed. Depending on the message semantics, one of these cases will apply:</p>
<ul>
<li>The Content-Length is specified and exceeds the limit. In this case the result <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81ac0912a1786d604cdb200087840fc74d0">error::body_limit</a> is returned immediately after the header is parsed.</li>
</ul>
<ul>
<li>The Content-Length is unspecified and the chunked encoding is not specified as the last encoding. In this case the end of message is determined by the end of file indicator on the associated stream or input source. If a sufficient number of body payload octets are presented to the parser to exceed the configured limit, the parse fails with the result <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81ac0912a1786d604cdb200087840fc74d0">error::body_limit</a></li>
</ul>
<ul>
<li>The Transfer-Encoding specifies the chunked encoding as the last encoding. In this case, when the number of payload body octets produced by removing the chunked encoding exceeds the configured limit, the parse fails with the result <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81ac0912a1786d604cdb200087840fc74d0">error::body_limit</a>.</li>
</ul>
<p>Setting the limit after any body octets have been parsed results in undefined behavior.</p>
<p>The default limit is 1MB for requests and 8MB for responses.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The payload body limit to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6db439b14f50f4898e7f7268fc9f37d8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast_1_1http.html#a2b9f3522dec08954593392b5b98372e4ad57c24f3fe52d16e7169b912dd647f0d">boost::optional</a>&lt; std::uint64_t &gt; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::content_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the optional value of Content-Length if known.</p>
<dl class="section note"><dt>Note</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abe2c565b37b248565113777047b8bd43">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae9e9bb5767f7b487faca7a42d8e651"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::eager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the eager parse option is set. </p>

</div>
</div>
<a class="anchor" id="a70ed7a48af0693ae501648917c0b518b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::eager </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the eager parse option.</p>
<p>Normally the parser returns after successfully parsing a structured element (header, chunk header, or chunk body) even if there are octets remaining in the input. This is necessary when attempting to parse the header first, or when the caller wants to inspect information which may be invalidated by subsequent parsing, such as a chunk extension. The <code>eager</code> option controls whether the parser keeps going after parsing structured element if there are octets remaining in the buffer and no error occurs. This option is automatically set or cleared during certain stream operations to improve performance with no change in functionality.</p>
<p>The default setting is <code>false</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>true</code> to set the eager parse option or <code>false</code> to disable it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf271f94c1fc15867eafb78cbcbaf729"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::got_some </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the parser has received at least one byte of input. </p>

</div>
</div>
<a class="anchor" id="a315563999dc446bab4ee2d0d3bebbc5e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::header_limit </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a limit on the total size of the header.</p>
<p>This function sets the maximum allowed size of the header including all field name, value, and delimiter characters and also including the CRLF sequences in the serialized input. If the end of the header is not found within the limit of the header size, the error <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81a89e441b0400b6e1fe047fc02f28fab59">error::header_limit</a> is returned by <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa7687744e64f99637505a762643d4717">put</a>.</p>
<p>Setting the limit after any header octets have been parsed results in undefined behavior. </p>

</div>
</div>
<a class="anchor" id="a35fa1a4c5410f6d8b4512bc3e6628c62"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::is_chunked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the last value for Transfer-Encoding is "chunked".</p>
<dl class="section note"><dt>Note</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abe2c565b37b248565113777047b8bd43">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a2353d732aa20fe50b548bb1da1c7f3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::is_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message is complete.</p>
<p>The message is complete after the full header is prduced and one of the following is true:</p>
<ul>
<li>The skip body option was set.</li>
</ul>
<ul>
<li>The semantics of the message indicate there is no body.</li>
</ul>
<ul>
<li>The semantics of the message indicate a body is expected, and the entire body was parsed. </li>
</ul>

</div>
</div>
<a class="anchor" id="abe2c565b37b248565113777047b8bd43"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::is_header_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if a the parser has produced the full header. </p>

</div>
</div>
<a class="anchor" id="a18ead94986d3d82ab9df5c348d33c204"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::is_keep_alive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message has keep-alive connection semantics.</p>
<dl class="section note"><dt>Note</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abe2c565b37b248565113777047b8bd43">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c754688183e96e3bf73ca0ef8a32ee1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::is_upgrade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message is an upgrade message.</p>
<dl class="section note"><dt>Note</dt><dd>The return value is undefined unless <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#abe2c565b37b248565113777047b8bd43">is_header_done</a> would return <code>true</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="acfec7ffb8a2bc8e5adec883acda5d2fc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::need_eof </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the message semantics require an end of file.</p>
<p>Depending on the contents of the header, the parser may require and end of file notification to know where the end of the body lies. If this function returns <code>true</code> it will be necessary to call <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#ad057df8cd62394aa7072771759492a7a">put_eof</a> when there will never be additional data from the input. </p>

</div>
</div>
<a class="anchor" id="ac9fcc94b6bae7e8617c4525e2c290e57"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&amp; <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a>&lt; isRequest, Derived &gt; const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a class="anchor" id="aa7687744e64f99637505a762643d4717"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::put </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a buffer sequence to the parser.</p>
<p>This function attempts to incrementally parse the HTTP message data stored in the caller provided buffers. Upon success, a positive return value indicates that the parser made forward progress, consuming that number of bytes.</p>
<p>In some cases there may be an insufficient number of octets in the input buffer in order to make forward progress. This is indicated by the code <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81a8b2ea992f8090045f758ff8e48d6b30f">error::need_more</a>. When this happens, the caller should place additional bytes into the buffer sequence and call <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa7687744e64f99637505a762643d4717">put</a> again.</p>
<p>The error code <a class="el" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81a8b2ea992f8090045f758ff8e48d6b30f">error::need_more</a> is special. When this error is returned, a subsequent call to <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html#aa7687744e64f99637505a762643d4717">put</a> may succeed if the buffers have been updated. Otherwise, upon error the parser may not be restarted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>An object meeting the requirements of <b>ConstBufferSequence</b> that represents the next chunk of message data. If the length of this buffer sequence is one, the implementation will not allocate additional memory. The class <a class="el" href="namespaceboost_1_1beast.html#a1647e26a51ca128f374bdb1b4438acf5">beast::flat_buffer</a> is provided as one way to meet this requirement</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of octets consumed in the buffer sequence. The caller should remove these octets even if the error is set. </dd></dl>

</div>
</div>
<a class="anchor" id="ac199c018acbc29b034a59e671ff604d0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::put </td>
          <td>(</td>
          <td class="paramtype">boost::asio::const_buffers_1 const &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad057df8cd62394aa7072771759492a7a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::put_eof </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inform the parser that the end of stream was reached.</p>
<p>In certain cases, HTTP needs to know where the end of the stream is. For example, sometimes servers send responses without Content-Length and expect the client to consume input (for the body) until EOF. Callbacks and errors will still be processed as usual.</p>
<p>This is typically called when a read from the underlying stream object sets the error code to <code>boost::asio::error::eof</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Only valid after parsing a complete header.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af888129a2e1a589fff926fbca3f2712a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::skip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the skip parse option is set. </p>

</div>
</div>
<a class="anchor" id="a2cb614d7566c2d0d7e69c572c80c0fcc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">boost::beast::http::basic_parser</a>&lt; isRequest, Derived &gt;::skip </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the skip parse option.</p>
<p>This option controls whether or not the parser expects to see an HTTP body, regardless of the presence or absence of certain fields such as Content-Length or a chunked Transfer-Encoding. Depending on the request, some responses do not carry a body. For example, a 200 response to a CONNECT request from a tunneling proxy, or a response to a HEAD request. In these cases, callers may use this function inform the parser that no body is expected. The parser will consider the message complete after the header has been received.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td><code>true</code> to set the skip body option or <code>false</code> to disable it.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function must called before any bytes are processed. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="af80fd5cd05d172059580176004255d23"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool isRequest, class Derived&gt; </div>
<div class="memtemplate">
template&lt;bool OtherIsRequest, class OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classboost_1_1beast_1_1http_1_1basic__parser.html">basic_parser</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>3pp/beast/boost/beast/http/<a class="el" href="basic__parser_8hpp_source.html">basic_parser.hpp</a></li>
<li>3pp/beast/boost/beast/http/impl/<a class="el" href="basic__parser_8ipp.html">basic_parser.ipp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
