<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ゴミ箱: boost::beast::zlib::inflate_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ゴミ箱
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast.html">beast</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html">zlib</a></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html">inflate_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classboost_1_1beast_1_1zlib_1_1inflate__stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::zlib::inflate_stream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="inflate__stream_8hpp_source.html">inflate_stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::beast::zlib::inflate_stream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1zlib_1_1inflate__stream.png" usemap="#boost::beast::zlib::inflate_5Fstream_map" alt=""/>
  <map id="boost::beast::zlib::inflate_5Fstream_map" name="boost::beast::zlib::inflate_stream_map">
<area href="classboost_1_1beast_1_1zlib_1_1detail_1_1inflate__stream.html" alt="boost::beast::zlib::detail::inflate_stream" shape="rect" coords="0,0,223,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a02c3ed1b058440cbf94e26fcbf76bbbf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html#a02c3ed1b058440cbf94e26fcbf76bbbf">inflate_stream</a> ()=default</td></tr>
<tr class="separator:a02c3ed1b058440cbf94e26fcbf76bbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda9158a7339417c6221bc85f3c0b60e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html#afda9158a7339417c6221bc85f3c0b60e">reset</a> ()</td></tr>
<tr class="separator:afda9158a7339417c6221bc85f3c0b60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23ac2299ffb253b4fb0e6934213dd0b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html#a23ac2299ffb253b4fb0e6934213dd0b4">reset</a> (int windowBits)</td></tr>
<tr class="separator:a23ac2299ffb253b4fb0e6934213dd0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c0b9b0343cc550d7413c1dd59b712af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html#a5c0b9b0343cc550d7413c1dd59b712af">clear</a> ()</td></tr>
<tr class="separator:a5c0b9b0343cc550d7413c1dd59b712af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d437ad73edeacac866ee92b58f12c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1inflate__stream.html#a1d437ad73edeacac866ee92b58f12c63">write</a> (<a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;zs, <a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41ac">Flush</a> flush, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a1d437ad73edeacac866ee92b58f12c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Raw deflate stream decompressor.</p>
<p>This implements a raw deflate stream decompressor. The deflate protocol is a compression protocol described in "DEFLATE Compressed Data Format Specification version 1.3" located here: <a href="https://tools.ietf.org/html/rfc1951">https://tools.ietf.org/html/rfc1951</a></p>
<p>The implementation is a refactored port to C++ of ZLib's "inflate". A more detailed description of ZLib is at <a href="http://zlib.net/">http://zlib.net/</a>.</p>
<p>Compression can be done in a single step if the buffers are large enough (for example if an input file is memory mapped), or can be done by repeated calls of the compression function. In the latter case, the application must provide more input and/or consume the output (providing more output space) before each call. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a02c3ed1b058440cbf94e26fcbf76bbbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::beast::zlib::inflate_stream::inflate_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a raw deflate decompression stream.</p>
<p>The window size is set to the default of 15 bits. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a5c0b9b0343cc550d7413c1dd59b712af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::inflate_stream::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Put the stream in a newly constructed state.</p>
<p>All dynamically allocated memory is de-allocated. </p>

</div>
</div>
<a class="anchor" id="afda9158a7339417c6221bc85f3c0b60e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::inflate_stream::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the stream.</p>
<p>This puts the stream in a newly constructed state with the previously specified window size, but without de-allocating any dynamically created structures. </p>

</div>
</div>
<a class="anchor" id="a23ac2299ffb253b4fb0e6934213dd0b4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::inflate_stream::reset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowBits</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the stream.</p>
<p>This puts the stream in a newly constructed state with the specified window size, but without de-allocating any dynamically created structures. </p>

</div>
</div>
<a class="anchor" id="a1d437ad73edeacac866ee92b58f12c63"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::inflate_stream::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;&#160;</td>
          <td class="paramname"><em>zs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41ac">Flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decompress input and produce output.</p>
<p>This function decompresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.</p>
<p>One or both of the following actions are performed:</p>
<ul>
<li>Decompress more input starting at <code>zs.next_in</code> and update <code>zs.next_in</code> and <code>zs.avail_in</code> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <code>zs.next_in</code> is updated and processing will resume at this point for the next call.</li>
</ul>
<ul>
<li>Provide more output starting at <code>zs.next_out</code> and update <code>zs.next_out</code> and <code>zs.avail_out</code> accordingly. <code>write</code> provides as much output as possible, until there is no more input data or no more space in the output buffer (see below about the flush parameter).</li>
</ul>
<p>Before the call, the application should ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating the values in <code>zs</code> accordingly. The application can consume the uncompressed output when it wants, for example when the output buffer is full (<code>zs.avail_out == 0</code>), or after each call. If <code>write</code> returns no error and with zero <code>zs.avail_out</code>, it must be called again after making room in the output buffer because there might be more output pending.</p>
<p>The flush parameter may be <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca334c4a4c42fdb79d7ebc3e73b517e6f8">Flush::none</a></code>, <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code>, <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code>, <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code>, or <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca2d5563ed288ac5396add9b78fbca810b">Flush::trees</a></code>. <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code> requests to flush as much output as possible to the output buffer. <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code> requests to stop if and when it gets to the next deflate block boundary. When decoding the zlib or gzip format, this will cause <code>write</code> to return immediately after the header and before the first block. When doing a raw inflate, <code>write</code> will go ahead and process the first block, and will return when it gets to the end of that block, or when it runs out of data.</p>
<p>The <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code> option assists in appending to or combining deflate streams. Also to assist in this, on return <code>write</code> will set <code>zs.data_type</code> to the number of unused bits in the last byte taken from <code>zs.next_in</code>, plus 64 if <code>write</code> is currently decoding the last block in the deflate stream, plus 128 if <code>write</code> returned immediately after decoding an end-of-block code or decoding the complete header up to just before the first byte of the deflate stream. The end-of-block will not be indicated until all of the uncompressed data from that block has been written to <code>zs.next_out</code>. The number of unused bits may in general be greater than seven, except when bit 7 of <code>zs.data_type</code> is set, in which case the number of unused bits will be less than eight. <code>zs.data_type</code> is set as noted here every time <code>write</code> returns for all flush options, and so can be used to determine the amount of currently consumed input in bits.</p>
<p>The <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca2d5563ed288ac5396add9b78fbca810b">Flush::trees</a></code> option behaves as <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code> does, but it also returns when the end of each deflate block header is reached, before any actual data in that block is decoded. This allows the caller to determine the length of the deflate block header for later use in random access within a deflate block. 256 is added to the value of <code>zs.data_type</code> when <code>write</code> returns immediately after reaching the end of the deflate block header.</p>
<p><code>write</code> should normally be called until it returns <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> or another error. However if all decompression is to be performed in a single step (a single call of <code>write</code>), the parameter flush should be set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code>. In this case all pending input is processed and all pending output is flushed; <code>zs.avail_out</code> must be large enough to hold all of the uncompressed data for the operation to complete. (The size of the uncompressed data may have been saved by the compressor for this purpose.) The use of <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code> is not required to perform an inflation in one step. However it may be used to inform inflate that a faster approach can be used for the single call. <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code> also informs inflate to not maintain a sliding window if the stream completes, which reduces inflate's memory footprint. If the stream does not complete, either because not all of the stream is provided or not enough output space is provided, then a sliding window will be allocated and <code>write</code> can be called again to continue the operation as if <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca334c4a4c42fdb79d7ebc3e73b517e6f8">Flush::none</a></code> had been used.</p>
<p>In this implementation, <code>write</code> always flushes as much output as possible to the output buffer, and always uses the faster approach on the first call. So the effects of the flush parameter in this implementation are on the return value of <code>write</code> as noted below, when <code>write</code> returns early when <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code> or <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca2d5563ed288ac5396add9b78fbca810b">Flush::trees</a></code> is used, and when <code>write</code> avoids the allocation of memory for a sliding window when <code>Flush::finsih</code> is used.</p>
<p>If a preset dictionary is needed after this call, <code>write</code> sets <code>zs.adler</code> to the Adler-32 checksum of the dictionary chosen by the compressor and returns <code>error::need_dictionary</code>; otherwise it sets <code>zs.adler</code> to the Adler-32 checksum of all output produced so far (that is, <code>zs.total_out bytes</code>) and returns no error, <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code>, or an error code as described below. At the end of the stream, <code>write</code> checks that its computed adler32 checksum is equal to that saved by the compressor and returns <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> only if the checksum is correct.</p>
<p>This function returns no error if some progress has been made (more input processed or more output produced), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> if the end of the compressed data has been reached and all uncompressed output has been produced, <code>error::need_dictionary</code> if a preset dictionary is needed at this point, <code>error::invalid_data</code> if the input data was corrupted (input stream not conforming to the zlib format or incorrect check value), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa0d86ac670386891bb8b223035353bddf">error::stream_error</a></code> if the stream structure was inconsistent (for example if <code>zs.next_in</code> or <code>zs.next_out</code> was null), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> if no progress is possible or if there was not enough room in the output buffer when <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code> is used. Note that <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> is not fatal, and <code>write</code> can be called again with more input and more output space to continue decompressing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>3pp/beast/boost/beast/zlib/<a class="el" href="inflate__stream_8hpp_source.html">inflate_stream.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
