<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ゴミ箱: boost::beast::zlib::deflate_stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ゴミ箱
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast.html">beast</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html">zlib</a></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html">deflate_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classboost_1_1beast_1_1zlib_1_1deflate__stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::zlib::deflate_stream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="deflate__stream_8hpp_source.html">deflate_stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for boost::beast::zlib::deflate_stream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1beast_1_1zlib_1_1deflate__stream.png" usemap="#boost::beast::zlib::deflate_5Fstream_map" alt=""/>
  <map id="boost::beast::zlib::deflate_5Fstream_map" name="boost::beast::zlib::deflate_stream_map">
<area href="classboost_1_1beast_1_1zlib_1_1detail_1_1deflate__stream.html" alt="boost::beast::zlib::detail::deflate_stream" shape="rect" coords="0,0,227,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6298820feddcb227eb25f1a68353d990"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a6298820feddcb227eb25f1a68353d990">deflate_stream</a> ()</td></tr>
<tr class="separator:a6298820feddcb227eb25f1a68353d990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360504fd50f2b086d9f7fc0669d8e08b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a360504fd50f2b086d9f7fc0669d8e08b">reset</a> (int level, int windowBits, int memLevel, <a class="el" href="namespaceboost_1_1beast_1_1zlib.html#addfbe0ef43405cd70ab08572ca5a5b8e">Strategy</a> strategy)</td></tr>
<tr class="separator:a360504fd50f2b086d9f7fc0669d8e08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27ca8675c40502c5f590701f71e99f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#af27ca8675c40502c5f590701f71e99f9">reset</a> ()</td></tr>
<tr class="separator:af27ca8675c40502c5f590701f71e99f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6071054d8afa58af247951e1f8ae97d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#aa6071054d8afa58af247951e1f8ae97d">clear</a> ()</td></tr>
<tr class="separator:aa6071054d8afa58af247951e1f8ae97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a83071066ddfb6fa2938b27ec3b9161"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a5a83071066ddfb6fa2938b27ec3b9161">upper_bound</a> (std::size_t sourceLen) const </td></tr>
<tr class="separator:a5a83071066ddfb6fa2938b27ec3b9161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503694e18ac4eaeb4de458744a8ec9b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a503694e18ac4eaeb4de458744a8ec9b2">tune</a> (int good_length, int max_lazy, int nice_length, int max_chain)</td></tr>
<tr class="separator:a503694e18ac4eaeb4de458744a8ec9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6990c7a1c79e9968a0703531037c58f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a6990c7a1c79e9968a0703531037c58f3">write</a> (<a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;zs, <a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41ac">Flush</a> flush, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a6990c7a1c79e9968a0703531037c58f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeff29671e473a6567a150be96c9331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#aceeff29671e473a6567a150be96c9331">params</a> (<a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;zs, int level, <a class="el" href="namespaceboost_1_1beast_1_1zlib.html#addfbe0ef43405cd70ab08572ca5a5b8e">Strategy</a> strategy, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:aceeff29671e473a6567a150be96c9331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9123c51a4cd1a1945c6545fdc835ba0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#ab9123c51a4cd1a1945c6545fdc835ba0">pending</a> (unsigned *value, int *bits)</td></tr>
<tr class="separator:ab9123c51a4cd1a1945c6545fdc835ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92b3f77eb6209de3f1d735c79c79d0b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#af92b3f77eb6209de3f1d735c79c79d0b">prime</a> (int bits, int value, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af92b3f77eb6209de3f1d735c79c79d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Raw deflate compressor.</p>
<p>This is a port of zlib's "deflate" functionality to C++. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6298820feddcb227eb25f1a68353d990"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::beast::zlib::deflate_stream::deflate_stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a default deflate stream.</p>
<p>Upon construction, the stream settings will be set to these default values:</p>
<ul>
<li><code>level = 6</code></li>
</ul>
<ul>
<li><code>windowBits = 15</code></li>
</ul>
<ul>
<li><code>memLevel = 8</code></li>
</ul>
<ul>
<li><code>strategy = <a class="el" href="namespaceboost_1_1beast_1_1zlib.html#addfbe0ef43405cd70ab08572ca5a5b8eafea087517c26fadd409bd4b9dc642555">Strategy::normal</a></code></li>
</ul>
<p>Although the stream is ready to be used immediately after construction, any required internal buffers are not dynamically allocated until needed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa6071054d8afa58af247951e1f8ae97d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the stream.</p>
<p>This function resets the stream and frees all dynamically allocated internal buffers. The compression settings are left unchanged.</p>
<dl class="section note"><dt>Note</dt><dd>Any unprocessed input or pending output from previous calls are discarded. </dd></dl>

</div>
</div>
<a class="anchor" id="aceeff29671e473a6567a150be96c9331"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::params </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;&#160;</td>
          <td class="paramname"><em>zs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#addfbe0ef43405cd70ab08572ca5a5b8e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update the compression level and strategy.</p>
<p>This function dynamically updates the compression level and compression strategy. The interpretation of level and strategy is as in <a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a360504fd50f2b086d9f7fc0669d8e08b">reset</a>. This can be used to switch between compression and straight copy of the input data, or to switch to a different kind of input data requiring a different strategy. If the compression level is changed, the input available so far is compressed with the old level (and may be flushed); the new level will take effect only at the next call of <a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a6990c7a1c79e9968a0703531037c58f3">write</a>.</p>
<p>Before the call of <code>params</code>, the stream state must be set as for a call of <a class="el" href="classboost_1_1beast_1_1zlib_1_1deflate__stream.html#a6990c7a1c79e9968a0703531037c58f3">write</a>, since the currently available input may have to be compressed and flushed. In particular, <code>zs.avail_out</code> must be non-zero.</p>
<dl class="section return"><dt>Returns</dt><dd><code>Z_OK</code> if success, <code>Z_STREAM_ERROR</code> if the source stream state was inconsistent or if a parameter was invalid, <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> if <code>zs.avail_out</code> was zero. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9123c51a4cd1a1945c6545fdc835ba0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::pending </td>
          <td>(</td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>bits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return bits pending in the output.</p>
<p>This function returns the number of bytes and bits of output that have been generated, but not yet provided in the available output. The bytes not provided would be due to the available output space having being consumed. The number of bits of output not provided are between 0 and 7, where they await more bits to join them in order to fill out a full byte. If pending or bits are <code>nullptr</code>, then those values are not set.</p>
<dl class="section return"><dt>Returns</dt><dd><code>Z_OK</code> if success, or <code>Z_STREAM_ERROR</code> if the source stream state was inconsistent. </dd></dl>

</div>
</div>
<a class="anchor" id="af92b3f77eb6209de3f1d735c79c79d0b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::prime </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insert bits into the compressed output stream.</p>
<p>This function inserts bits in the deflate output stream. The intent is that this function is used to start off the deflate output with the bits leftover from a previous deflate stream when appending to it. As such, this function can only be used for raw deflate, and must be used before the first <code>write</code> call after an initialization. <code>bits</code> must be less than or equal to 16, and that many of the least significant bits of <code>value</code> will be inserted in the output.</p>
<dl class="section return"><dt>Returns</dt><dd><code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> if there was not enough room in the internal buffer to insert the bits. </dd></dl>

</div>
</div>
<a class="anchor" id="a360504fd50f2b086d9f7fc0669d8e08b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::reset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>windowBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>memLevel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#addfbe0ef43405cd70ab08572ca5a5b8e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the stream and compression settings.</p>
<p>This function initializes the stream to the specified compression settings.</p>
<p>Although the stream is ready to be used immediately after a reset, any required internal buffers are not dynamically allocated until needed.</p>
<dl class="section note"><dt>Note</dt><dd>Any unprocessed input or pending output from previous calls are discarded. </dd></dl>

</div>
</div>
<a class="anchor" id="af27ca8675c40502c5f590701f71e99f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the stream without deallocating memory.</p>
<p>This function performs the equivalent of calling <code>clear</code> followed by <code>reset</code> with the same compression settings, without deallocating the internal buffers.</p>
<dl class="section note"><dt>Note</dt><dd>Any unprocessed input or pending output from previous calls are discarded. </dd></dl>

</div>
</div>
<a class="anchor" id="a503694e18ac4eaeb4de458744a8ec9b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::tune </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>good_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_lazy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nice_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fine tune internal compression parameters.</p>
<p>Compression parameters should only be tuned by someone who understands the algorithm used by zlib's deflate for searching for the best matching string, and even then only by the most fanatic optimizer trying to squeeze out the last compressed bit for their specific input data. Read the deflate.c source code (ZLib) for the meaning of the max_lazy, good_length, nice_length, and max_chain parameters. </p>

</div>
</div>
<a class="anchor" id="a5a83071066ddfb6fa2938b27ec3b9161"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t boost::beast::zlib::deflate_stream::upper_bound </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>sourceLen</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the upper limit on the size of a compressed block.</p>
<p>This function makes a conservative estimate of the maximum number of bytes needed to store the result of compressing a block of data based on the current compression level and strategy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceLen</td><td>The size of the uncompressed data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of resulting compressed bytes. </dd></dl>

</div>
</div>
<a class="anchor" id="a6990c7a1c79e9968a0703531037c58f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boost::beast::zlib::deflate_stream::write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1zlib_1_1z__params.html">z_params</a> &amp;&#160;</td>
          <td class="paramname"><em>zs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41ac">Flush</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compress input and write output.</p>
<p>This function compresses as much data as possible, and stops when the input buffer becomes empty or the output buffer becomes full. It may introduce some output latency (reading input without producing any output) except when forced to flush.</p>
<p>In each call, one or both of these actions are performed:</p>
<ul>
<li>Compress more input starting at <code>zs.next_in</code> and update <code>zs.next_in</code> and <code>zs.avail_in</code> accordingly. If not all input can be processed (because there is not enough room in the output buffer), <code>zs.next_in</code> and <code>zs.avail_in</code> are updated and processing will resume at this point for the next call.</li>
</ul>
<ul>
<li>Provide more output starting at <code>zs.next_out</code> and update <code>zs.next_out</code> and <code>zs.avail_out</code> accordingly. This action is forced if the parameter flush is not <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca334c4a4c42fdb79d7ebc3e73b517e6f8">Flush::none</a></code>. Forcing flush frequently degrades the compression ratio, so this parameter should be set only when necessary (in interactive applications). Some output may be provided even if flush is not set.</li>
</ul>
<p>Before the call, the application must ensure that at least one of the actions is possible, by providing more input and/or consuming more output, and updating <code>zs.avail_in</code> or <code>zs.avail_out</code> accordingly; <code>zs.avail_out</code> should never be zero before the call. The application can consume the compressed output when it wants, for example when the output buffer is full (<code>zs.avail_out == 0</code>), or after each call of <code>write</code>. If <code>write</code> returns no error with zero <code>zs.avail_out</code>, it must be called again after making room in the output buffer because there might be more output pending.</p>
<p>Normally the parameter flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca334c4a4c42fdb79d7ebc3e73b517e6f8">Flush::none</a></code>, which allows deflate to decide how much data to accumulate before producing output, in order to maximize compression.</p>
<p>If the parameter flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code>, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. In particular <code>zs.avail_in</code> is zero after the call if enough output space has been provided before the call. Flushing may degrade compression for some compression algorithms and so it should be used only when necessary. This completes the current deflate block and follows it with an empty stored block that is three bits plus filler bits to the next byte, followed by the four bytes <code>{ 0x00, 0x00 0xff 0xff }</code>.</p>
<p>If flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca0e87c1212a698494dcdb198af3e0eb2f">Flush::partial</a></code>, all pending output is flushed to the output buffer, but the output is not aligned to a byte boundary. All of the input data so far will be available to the decompressor, as for Z_SYNC_FLUSH. This completes the current deflate block and follows it with an empty fixed codes block that is 10 bits long. This assures that enough bytes are output in order for the decompressor to finish the block before the empty fixed code block.</p>
<p>If flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca14511f2f5564650d129ca7cabc333278">Flush::block</a></code>, a deflate block is completed and emitted, as for <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code>, but the output is not aligned on a byte boundary, and up to seven bits of the current block are held to be written as the next byte after the next deflate block is completed. In this case, the decompressor may not be provided enough bits at this point in order to complete decompression of the data provided so far to the compressor. It may need to wait for the next block to be emitted. This is for advanced applications that need to control the emission of deflate blocks.</p>
<p>If flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41acae9dc924f238fa6cc29465942875fe8f0">Flush::full</a></code>, all output is flushed as with <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code>, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41acae9dc924f238fa6cc29465942875fe8f0">Flush::full</a></code> too often can seriously degrade compression.</p>
<p>If <code>write</code> returns with <code>zs.avail_out == 0</code>, this function must be called again with the same value of the flush parameter and more output space (updated <code>zs.avail_out</code>), until the flush is complete (<code>write</code> returns with non-zero <code>zs.avail_out</code>). In the case of a <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41acae9dc924f238fa6cc29465942875fe8f0">Flush::full</a></code>or <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca63ad9d34f3503826e5f649ae6b7ac92c">Flush::sync</a></code>, make sure that <code>zs.avail_out</code> is greater than six to avoid repeated flush markers due to <code>zs.avail_out == 0</code> on return.</p>
<p>If the parameter flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code>, pending input is processed, pending output is flushed and deflate returns the error <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> if there was enough output space; if deflate returns with no error, this function must be called again with <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code> and more output space (updated <code>zs.avail_out</code>) but no more input data, until it returns the error <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> or another error. After <code>write</code> has returned the <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> error, the only possible operations on the stream are to reset or destroy.</p>
<p><code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code> can be used immediately after initialization if all the compression is to be done in a single step. In this case, <code>zs.avail_out</code> must be at least value returned by <code>upper_bound</code> (see below). Then <code>write</code> is guaranteed to return the <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> error. If not enough output space is provided, deflate will not return <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code>, and it must be called again as described above.</p>
<p><code>write</code> returns no error if some progress has been made (more input processed or more output produced), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa09f3645c755dc42466f97cbbc7896000">error::end_of_stream</a></code> if all input has been consumed and all output has been produced (only when flush is set to <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#a398a67333361753819e281893fdf41aca3248bc7547ce97b2a197b2a06cf7283d">Flush::finish</a></code>), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aa0d86ac670386891bb8b223035353bddf">error::stream_error</a></code> if the stream state was inconsistent (for example if <code>zs.next_in</code> or <code>zs.next_out</code> was <code>nullptr</code>), <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> if no progress is possible (for example <code>zs.avail_in</code> or <code>zs.avail_out</code> was zero). Note that <code><a class="el" href="namespaceboost_1_1beast_1_1zlib.html#ab71ce423732e4858b3a4e4a6f3a3733aac81a1e445d0b8538907c709f8c3a3f19">error::need_buffers</a></code> is not fatal, and <code>write</code> can be called again with more input and more output space to continue compressing. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>3pp/beast/boost/beast/zlib/<a class="el" href="deflate__stream_8hpp_source.html">deflate_stream.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
