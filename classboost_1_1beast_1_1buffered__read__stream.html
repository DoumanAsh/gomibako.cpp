<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ゴミ箱: boost::beast::buffered_read_stream&lt; Stream, DynamicBuffer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ゴミ箱
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast.html">beast</a></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classboost_1_1beast_1_1buffered__read__stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::buffered_read_stream&lt; Stream, DynamicBuffer &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a46cfab0977a97141dce3066cb293a014"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a46cfab0977a97141dce3066cb293a014">buffer_type</a> = DynamicBuffer</td></tr>
<tr class="memdesc:a46cfab0977a97141dce3066cb293a014"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the internal buffer.  <a href="#a46cfab0977a97141dce3066cb293a014">More...</a><br /></td></tr>
<tr class="separator:a46cfab0977a97141dce3066cb293a014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cba99566586b691901f1157bce08857"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> = typename std::remove_reference&lt; Stream &gt;::type</td></tr>
<tr class="memdesc:a0cba99566586b691901f1157bce08857"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer.  <a href="#a0cba99566586b691901f1157bce08857">More...</a><br /></td></tr>
<tr class="separator:a0cba99566586b691901f1157bce08857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1390201b09bb8daa7f4c50eb74cb92"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a> = typename <a class="el" href="structboost_1_1beast_1_1get__lowest__layer.html">get_lowest_layer</a>&lt; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> &gt;::type</td></tr>
<tr class="memdesc:a0f1390201b09bb8daa7f4c50eb74cb92"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the lowest layer.  <a href="#a0f1390201b09bb8daa7f4c50eb74cb92">More...</a><br /></td></tr>
<tr class="separator:a0f1390201b09bb8daa7f4c50eb74cb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8bf5f9062db879343197fdc558c141da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a8bf5f9062db879343197fdc558c141da">buffered_read_stream</a> (<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a8bf5f9062db879343197fdc558c141da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f6608018f0380efaf15bec2c8e9b0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#aa9f6608018f0380efaf15bec2c8e9b0f">operator=</a> (<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:aa9f6608018f0380efaf15bec2c8e9b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cc169af9178c23485c3e5ec405ac97"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a38cc169af9178c23485c3e5ec405ac97"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a38cc169af9178c23485c3e5ec405ac97">buffered_read_stream</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a38cc169af9178c23485c3e5ec405ac97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68fde8faec56a5759026d097480383c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a68fde8faec56a5759026d097480383c9">next_layer</a> ()</td></tr>
<tr class="memdesc:a68fde8faec56a5759026d097480383c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the next layer.  <a href="#a68fde8faec56a5759026d097480383c9">More...</a><br /></td></tr>
<tr class="separator:a68fde8faec56a5759026d097480383c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ccd52e8c4d88c7249fe9ccdaeac305"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ab1ccd52e8c4d88c7249fe9ccdaeac305">next_layer</a> () const </td></tr>
<tr class="memdesc:ab1ccd52e8c4d88c7249fe9ccdaeac305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the next layer.  <a href="#ab1ccd52e8c4d88c7249fe9ccdaeac305">More...</a><br /></td></tr>
<tr class="separator:ab1ccd52e8c4d88c7249fe9ccdaeac305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45fdc348e8ae4fc6d4d5d66dc331871"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#af45fdc348e8ae4fc6d4d5d66dc331871">lowest_layer</a> ()</td></tr>
<tr class="memdesc:af45fdc348e8ae4fc6d4d5d66dc331871"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the lowest layer.  <a href="#af45fdc348e8ae4fc6d4d5d66dc331871">More...</a><br /></td></tr>
<tr class="separator:af45fdc348e8ae4fc6d4d5d66dc331871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f520c92ae9d1cc4849df7a4cd450932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a9f520c92ae9d1cc4849df7a4cd450932">lowest_layer</a> () const </td></tr>
<tr class="memdesc:a9f520c92ae9d1cc4849df7a4cd450932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the lowest layer.  <a href="#a9f520c92ae9d1cc4849df7a4cd450932">More...</a><br /></td></tr>
<tr class="separator:a9f520c92ae9d1cc4849df7a4cd450932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af744120ac93e7137186d1b7c6f0716c5"><td class="memItemLeft" align="right" valign="top">boost::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#af744120ac93e7137186d1b7c6f0716c5">get_io_service</a> ()</td></tr>
<tr class="memdesc:af744120ac93e7137186d1b7c6f0716c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the io_service associated with the object.  <a href="#af744120ac93e7137186d1b7c6f0716c5">More...</a><br /></td></tr>
<tr class="separator:af744120ac93e7137186d1b7c6f0716c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cee0734247bb0bbe28c23dd9e199e5"><td class="memItemLeft" align="right" valign="top">DynamicBuffer &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a09cee0734247bb0bbe28c23dd9e199e5">buffer</a> ()</td></tr>
<tr class="separator:a09cee0734247bb0bbe28c23dd9e199e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93a82d9541016c104fa2bb6e1eb1493"><td class="memItemLeft" align="right" valign="top">DynamicBuffer const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ad93a82d9541016c104fa2bb6e1eb1493">buffer</a> () const </td></tr>
<tr class="memdesc:ad93a82d9541016c104fa2bb6e1eb1493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the internal buffer.  <a href="#ad93a82d9541016c104fa2bb6e1eb1493">More...</a><br /></td></tr>
<tr class="separator:ad93a82d9541016c104fa2bb6e1eb1493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f5af2daed36e940a468e5c417367ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ac0f5af2daed36e940a468e5c417367ec">capacity</a> (std::size_t size)</td></tr>
<tr class="separator:ac0f5af2daed36e940a468e5c417367ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256284c91e8c07261f734f5655415e05"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a256284c91e8c07261f734f5655415e05"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a256284c91e8c07261f734f5655415e05">read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:a256284c91e8c07261f734f5655415e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af612f292a3a2c3b50c213a5d1af7b766"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:af612f292a3a2c3b50c213a5d1af7b766"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#af612f292a3a2c3b50c213a5d1af7b766">read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af612f292a3a2c3b50c213a5d1af7b766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49d335f46991317bfdc90b6b0e22cc6"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , class ReadHandler &gt; </td></tr>
<tr class="memitem:ad49d335f46991317bfdc90b6b0e22cc6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ad49d335f46991317bfdc90b6b0e22cc6">async_read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="separator:ad49d335f46991317bfdc90b6b0e22cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a7ecec3fc91bd6a4abfeb225c1822e20f">write_some</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:a7ecec3fc91bd6a4abfeb225c1822e20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac452101fc0403cfb156cc4bf8251465f"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac452101fc0403cfb156cc4bf8251465f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#ac452101fc0403cfb156cc4bf8251465f">write_some</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac452101fc0403cfb156cc4bf8251465f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240d027c2ae66808b064554a528d91b5"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class WriteHandler &gt; </td></tr>
<tr class="memitem:a240d027c2ae66808b064554a528d91b5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a240d027c2ae66808b064554a528d91b5">async_write_some</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a240d027c2ae66808b064554a528d91b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8d2b0751a49eede24bb9ec6bc0d492"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class WriteHandler &gt; </td></tr>
<tr class="memitem:acd8d2b0751a49eede24bb9ec6bc0d492"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#acd8d2b0751a49eede24bb9ec6bc0d492">async_write_some</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, WriteHandler &amp;&amp;handler) -&gt; <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;</td></tr>
<tr class="separator:acd8d2b0751a49eede24bb9ec6bc0d492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea999fed9e3b60095fdfc4cae844c0f"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , class ReadHandler &gt; </td></tr>
<tr class="memitem:a4ea999fed9e3b60095fdfc4cae844c0f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a4ea999fed9e3b60095fdfc4cae844c0f">async_read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ReadHandler &amp;&amp;handler) -&gt; <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;</td></tr>
<tr class="separator:a4ea999fed9e3b60095fdfc4cae844c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class Stream, class DynamicBuffer&gt;<br />
class boost::beast::buffered_read_stream&lt; Stream, DynamicBuffer &gt;</h3>

<p>A <b>Stream</b> with attached <b>DynamicBuffer</b> to buffer reads.</p>
<p>This wraps a <b>Stream</b> implementation so that calls to write are passed through to the underlying stream, while calls to read will first consume the input sequence stored in a <b>DynamicBuffer</b> which is part of the object.</p>
<p>The use-case for this class is different than that of the <code>boost::asio::buffered_readstream</code>. It is designed to facilitate the use of <code>boost::asio::read_until</code>, and to allow buffers acquired during detection of handshakes to be made transparently available to callers. A hypothetical implementation of the buffered version of <code>boost::asio::ssl::stream::async_handshake</code> could make use of this wrapper.</p>
<p>Uses:</p>
<ul>
<li>Transparently leave untouched input acquired in calls to <code>boost::asio::read_until</code> behind for subsequent callers.</li>
</ul>
<ul>
<li>"Preload" a stream with handshake input data acquired from other sources.</li>
</ul>
<p>Example: </p><div class="fragment"><div class="line"><span class="comment">// Process the next HTTP header on the stream,</span></div><div class="line"><span class="comment">// leaving excess bytes behind for the next call.</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> DynamicBuffer&gt;</div><div class="line"><span class="keywordtype">void</span> process_http_message(</div><div class="line">    buffered_read_stream&lt;DynamicBuffer&gt;&amp; stream)</div><div class="line">{</div><div class="line">    <span class="comment">// Read up to and including the end of the HTTP</span></div><div class="line">    <span class="comment">// header, leaving the sequence in the stream&#39;s</span></div><div class="line">    <span class="comment">// buffer. read_until may read past the end of the</span></div><div class="line">    <span class="comment">// headers; the return value will include only the</span></div><div class="line">    <span class="comment">// part up to the end of the delimiter.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    std::size_t bytes_transferred =</div><div class="line">        boost::asio::read_until(</div><div class="line">            stream.next_layer(), stream.buffer(), <span class="stringliteral">&quot;\r\n\r\n&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Use buffer_prefix() to limit the input</span></div><div class="line">    <span class="comment">// sequence to only the data up to and including</span></div><div class="line">    <span class="comment">// the trailing &quot;\r\n\r\n&quot;.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">auto</span> header_buffers = <a class="code" href="namespaceboost_1_1beast.html#ab4c9fc685e69675beb9883c0b54d222c">buffer_prefix</a>(</div><div class="line">        bytes_transferred, stream.buffer().data());</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="comment">// Discard the portion of the input corresponding</span></div><div class="line">    <span class="comment">// to the HTTP headers.</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    stream.buffer().consume(bytes_transferred);</div><div class="line"></div><div class="line">    <span class="comment">// Everything we read from the stream</span></div><div class="line">    <span class="comment">// is part of the content-body.</span></div><div class="line">}</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stream</td><td>The type of stream to wrap.</td></tr>
    <tr><td class="paramname">DynamicBuffer</td><td>The type of stream buffer to use. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a46cfab0977a97141dce3066cb293a014"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a46cfab0977a97141dce3066cb293a014">buffer_type</a> =  DynamicBuffer</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the internal buffer. </p>

</div>
</div>
<a class="anchor" id="a0f1390201b09bb8daa7f4c50eb74cb92"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a> =  typename <a class="el" href="structboost_1_1beast_1_1get__lowest__layer.html">get_lowest_layer</a>&lt;<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the lowest layer. </p>

</div>
</div>
<a class="anchor" id="a0cba99566586b691901f1157bce08857"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> =  typename std::remove_reference&lt;Stream&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the next layer. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8bf5f9062db879343197fdc558c141da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a38cc169af9178c23485c3e5ec405ac97"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::<a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct the wrapping stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Parameters forwarded to the <code>Stream</code> constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4ea999fed9e3b60095fdfc4cae844c0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , class ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt;ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad49d335f46991317bfdc90b6b0e22cc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , class ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt;ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous read.</p>
<p>This function is used to asynchronously read data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; <a class="code" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81">error</a>,      <span class="comment">// result of operation</span></div><div class="line">    std::size_t bytes_transferred <span class="comment">// number of bytes transferred</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd8d2b0751a49eede24bb9ec6bc0d492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt;WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;
</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a240d027c2ae66808b064554a528d91b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt;WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous write.</p>
<p>This function is used to asynchronously write data from the stream. The function call always returns immediately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream. Although the buffers object may be copied as necessary, ownership of the underlying memory blocks is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; <a class="code" href="namespaceboost_1_1beast_1_1http.html#a12540700977fe07dcb84aa3493556c81">error</a>,      <span class="comment">// result of operation</span></div><div class="line">    std::size_t bytes_transferred <span class="comment">// number of bytes transferred</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09cee0734247bb0bbe28c23dd9e199e5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the internal buffer.</p>
<p>The internal buffer is returned. It is possible for the caller to break invariants with this function. For example, by causing the internal buffer size to increase beyond the caller defined maximum. </p>

</div>
</div>
<a class="anchor" id="ad93a82d9541016c104fa2bb6e1eb1493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DynamicBuffer const&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::buffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the internal buffer. </p>

</div>
</div>
<a class="anchor" id="ac0f5af2daed36e940a468e5c417367ec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::capacity </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum buffer size.</p>
<p>This changes the maximum size of the internal buffer used to hold read data. No bytes are discarded by this call. If the buffer size is set to zero, no more data will be buffered.</p>
<p>Thread safety: The caller is responsible for making sure the call is made from the same implicit or explicit strand.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of bytes in the read buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This is a soft limit. If the new maximum size is smaller than the amount of data in the buffer, no bytes are discarded. </dd></dl>

</div>
</div>
<a class="anchor" id="af744120ac93e7137186d1b7c6f0716c5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_service&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the io_service associated with the object. </p>

</div>
</div>
<a class="anchor" id="af45fdc348e8ae4fc6d4d5d66dc331871"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the lowest layer. </p>

</div>
</div>
<a class="anchor" id="a9f520c92ae9d1cc4849df7a4cd450932"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0f1390201b09bb8daa7f4c50eb74cb92">lowest_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the lowest layer. </p>

</div>
</div>
<a class="anchor" id="a68fde8faec56a5759026d097480383c9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the next layer. </p>

</div>
</div>
<a class="anchor" id="ab1ccd52e8c4d88c7249fe9ccdaeac305"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html#a0cba99566586b691901f1157bce08857">next_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a const reference to the next layer. </p>

</div>
</div>
<a class="anchor" id="aa9f6608018f0380efaf15bec2c8e9b0f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&amp; <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a256284c91e8c07261f734f5655415e05"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af612f292a3a2c3b50c213a5d1af7b766"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read some data from the stream.</p>
<p>This function is used to read data from the stream. The function call will block until one or more bytes of data has been read successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more buffers into which the data will be read.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes read, or 0 on error. </dd></dl>

</div>
</div>
<a class="anchor" id="a7ecec3fc91bd6a4abfeb225c1822e20f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac452101fc0403cfb156cc4bf8251465f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Stream , class DynamicBuffer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">boost::beast::buffered_read_stream</a>&lt; Stream, DynamicBuffer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write some data to the stream.</p>
<p>This function is used to write data to the stream. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>One or more data buffers to be written to the stream.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to the error, if any occurred.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes written. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>3pp/beast/boost/beast/core/<a class="el" href="buffered__read__stream_8hpp_source.html">buffered_read_stream.hpp</a></li>
<li>3pp/beast/boost/beast/core/impl/<a class="el" href="buffered__read__stream_8ipp.html">buffered_read_stream.ipp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
