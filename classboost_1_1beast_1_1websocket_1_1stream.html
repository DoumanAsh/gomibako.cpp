<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>ゴミ箱: boost::beast::websocket::stream&lt; NextLayer &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ゴミ箱
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceboost.html">boost</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast.html">beast</a></li><li class="navelem"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html">websocket</a></li><li class="navelem"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classboost_1_1beast_1_1websocket_1_1stream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">boost::beast::websocket::stream&lt; NextLayer &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="stream_8hpp_source.html">stream.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1accept__op.html">accept_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1close__op.html">close_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1fail__op.html">fail_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1handshake__op.html">handshake_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1ping__op.html">ping_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1read__op.html">read_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1read__some__op.html">read_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1response__op.html">response_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream_1_1write__some__op.html">write_some_op</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aab063b550f536e3c0d16c409cdaf2da4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> = typename std::remove_reference&lt; NextLayer &gt;::type</td></tr>
<tr class="memdesc:aab063b550f536e3c0d16c409cdaf2da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the next layer.  <a href="#aab063b550f536e3c0d16c409cdaf2da4">More...</a><br /></td></tr>
<tr class="separator:aab063b550f536e3c0d16c409cdaf2da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6118df5dd6f1bdb4adfd10886ce6b3d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a> = typename <a class="el" href="structboost_1_1beast_1_1get__lowest__layer.html">get_lowest_layer</a>&lt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> &gt;::type</td></tr>
<tr class="memdesc:ab6118df5dd6f1bdb4adfd10886ce6b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of the lowest layer.  <a href="#ab6118df5dd6f1bdb4adfd10886ce6b3d">More...</a><br /></td></tr>
<tr class="separator:ab6118df5dd6f1bdb4adfd10886ce6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a140a6d95423fe52f2d18a95391b3d740"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a140a6d95423fe52f2d18a95391b3d740">~stream</a> ()=default</td></tr>
<tr class="separator:a140a6d95423fe52f2d18a95391b3d740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1d62ec245a36fe69aa68a0f1bea191"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3b1d62ec245a36fe69aa68a0f1bea191">stream</a> (<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3b1d62ec245a36fe69aa68a0f1bea191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac639ff02b59da6f2dac2d384571257"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3ac639ff02b59da6f2dac2d384571257">operator=</a> (<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> &amp;&amp;)=default</td></tr>
<tr class="separator:a3ac639ff02b59da6f2dac2d384571257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d3990969881f791aa6f724747abd98"><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr class="memitem:a75d3990969881f791aa6f724747abd98"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a75d3990969881f791aa6f724747abd98">stream</a> (Args &amp;&amp;...args)</td></tr>
<tr class="separator:a75d3990969881f791aa6f724747abd98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d10d0babb037694e781e3f45cbe7dae"><td class="memItemLeft" align="right" valign="top">boost::asio::io_service &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5d10d0babb037694e781e3f45cbe7dae">get_io_service</a> ()</td></tr>
<tr class="separator:a5d10d0babb037694e781e3f45cbe7dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5420f2bafaadb6fdba002dd889b615e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5420f2bafaadb6fdba002dd889b615e7">next_layer</a> ()</td></tr>
<tr class="separator:a5420f2bafaadb6fdba002dd889b615e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7f56e10c9ff8105317a87a1cc3f6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2c7f56e10c9ff8105317a87a1cc3f6a6">next_layer</a> () const </td></tr>
<tr class="separator:a2c7f56e10c9ff8105317a87a1cc3f6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f82c817a53fc8fe6109da1ce89b7de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a34f82c817a53fc8fe6109da1ce89b7de">lowest_layer</a> ()</td></tr>
<tr class="separator:a34f82c817a53fc8fe6109da1ce89b7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94b33ccf6b9a4a6db72e230ebb031493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a94b33ccf6b9a4a6db72e230ebb031493">lowest_layer</a> () const </td></tr>
<tr class="separator:a94b33ccf6b9a4a6db72e230ebb031493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f1ec62c55d8752564396ffd5797e0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> () const </td></tr>
<tr class="separator:a11f1ec62c55d8752564396ffd5797e0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a13693e92798fba7eae53f459960b86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> () const </td></tr>
<tr class="separator:a0a13693e92798fba7eae53f459960b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2686f5f4adcacca7a2f7c4090895cd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> () const </td></tr>
<tr class="memdesc:ad2686f5f4adcacca7a2f7c4090895cd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the last completed read finished the current message.  <a href="#ad2686f5f4adcacca7a2f7c4090895cd2">More...</a><br /></td></tr>
<tr class="separator:ad2686f5f4adcacca7a2f7c4090895cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3547029823ff37f30e71aaf25c87da3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3547029823ff37f30e71aaf25c87da3f">reason</a> () const </td></tr>
<tr class="separator:a3547029823ff37f30e71aaf25c87da3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17615771a24bb059f4dea7da584901da"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a17615771a24bb059f4dea7da584901da">read_size_hint</a> (std::size_t initial_size=+tcp_frame_size) const </td></tr>
<tr class="separator:a17615771a24bb059f4dea7da584901da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5dffd3acda5b092151832be0b6ca516"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , class  = typename std::enable_if&lt;            ! std::is_integral&lt;DynamicBuffer&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:ae5dffd3acda5b092151832be0b6ca516"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae5dffd3acda5b092151832be0b6ca516">read_size_hint</a> (DynamicBuffer &amp;buffer) const </td></tr>
<tr class="separator:ae5dffd3acda5b092151832be0b6ca516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9b8d70576c22f3768c2503f272259f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a1b9b8d70576c22f3768c2503f272259f">set_option</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> const &amp;o)</td></tr>
<tr class="memdesc:a1b9b8d70576c22f3768c2503f272259f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the permessage-deflate extension options.  <a href="#a1b9b8d70576c22f3768c2503f272259f">More...</a><br /></td></tr>
<tr class="separator:a1b9b8d70576c22f3768c2503f272259f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab088b13a806fac1ede8b104429ca2c95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab088b13a806fac1ede8b104429ca2c95">get_option</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> &amp;o)</td></tr>
<tr class="memdesc:ab088b13a806fac1ede8b104429ca2c95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the permessage-deflate extension options.  <a href="#ab088b13a806fac1ede8b104429ca2c95">More...</a><br /></td></tr>
<tr class="separator:ab088b13a806fac1ede8b104429ca2c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b34aa1feb4bddf99490b0383c78cc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a99b34aa1feb4bddf99490b0383c78cc5">auto_fragment</a> (bool value)</td></tr>
<tr class="separator:a99b34aa1feb4bddf99490b0383c78cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5017428f6852bbace4b0b2bc672577c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5017428f6852bbace4b0b2bc672577c1">auto_fragment</a> () const </td></tr>
<tr class="memdesc:a5017428f6852bbace4b0b2bc672577c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the automatic fragmentation option is set.  <a href="#a5017428f6852bbace4b0b2bc672577c1">More...</a><br /></td></tr>
<tr class="separator:a5017428f6852bbace4b0b2bc672577c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd8bbab79019ecc97dc9b67bf5a120a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> (bool value)</td></tr>
<tr class="separator:a3dd8bbab79019ecc97dc9b67bf5a120a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fc0ba9ddbea98a3b4e02c298d3f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2c0fc0ba9ddbea98a3b4e02c298d3f46">binary</a> () const </td></tr>
<tr class="memdesc:a2c0fc0ba9ddbea98a3b4e02c298d3f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the binary message option is set.  <a href="#a2c0fc0ba9ddbea98a3b4e02c298d3f46">More...</a><br /></td></tr>
<tr class="separator:a2c0fc0ba9ddbea98a3b4e02c298d3f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1b674c997a6a86b36ea5c467ae449f"><td class="memTemplParams" colspan="2">template&lt;class Callback &gt; </td></tr>
<tr class="memitem:a7e1b674c997a6a86b36ea5c467ae449f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> (Callback &amp;cb)</td></tr>
<tr class="separator:a7e1b674c997a6a86b36ea5c467ae449f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade292bb6341560a9386a8b06a3db7062"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ade292bb6341560a9386a8b06a3db7062">control_callback</a> ()</td></tr>
<tr class="separator:ade292bb6341560a9386a8b06a3db7062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f932bd02a9737e295ee23a07f9f0b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa9f932bd02a9737e295ee23a07f9f0b5">read_message_max</a> (std::size_t amount)</td></tr>
<tr class="separator:aa9f932bd02a9737e295ee23a07f9f0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a62ec09983e1489b8fe6c1c694ae23b"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8a62ec09983e1489b8fe6c1c694ae23b">read_message_max</a> () const </td></tr>
<tr class="memdesc:a8a62ec09983e1489b8fe6c1c694ae23b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum incoming message size setting.  <a href="#a8a62ec09983e1489b8fe6c1c694ae23b">More...</a><br /></td></tr>
<tr class="separator:a8a62ec09983e1489b8fe6c1c694ae23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a470ba89aa87d3ead769bcdfa3ebab81c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a470ba89aa87d3ead769bcdfa3ebab81c">write_buffer_size</a> (std::size_t amount)</td></tr>
<tr class="separator:a470ba89aa87d3ead769bcdfa3ebab81c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1b796d75b4a0a9f8d63e2f8e598e7e2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa1b796d75b4a0a9f8d63e2f8e598e7e2">write_buffer_size</a> () const </td></tr>
<tr class="memdesc:aa1b796d75b4a0a9f8d63e2f8e598e7e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the write buffer.  <a href="#aa1b796d75b4a0a9f8d63e2f8e598e7e2">More...</a><br /></td></tr>
<tr class="separator:aa1b796d75b4a0a9f8d63e2f8e598e7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2907a1047f19201a56383304ec0baf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#acb2907a1047f19201a56383304ec0baf">text</a> (bool value)</td></tr>
<tr class="separator:acb2907a1047f19201a56383304ec0baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d7511b1d1f9e1657d96189d8b85d070"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6d7511b1d1f9e1657d96189d8b85d070">text</a> () const </td></tr>
<tr class="memdesc:a6d7511b1d1f9e1657d96189d8b85d070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the text message option is set.  <a href="#a6d7511b1d1f9e1657d96189d8b85d070">More...</a><br /></td></tr>
<tr class="separator:a6d7511b1d1f9e1657d96189d8b85d070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac042c1ac78d2cdcfaa2b10c45e9c166b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac042c1ac78d2cdcfaa2b10c45e9c166b">handshake</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target)</td></tr>
<tr class="separator:ac042c1ac78d2cdcfaa2b10c45e9c166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa961f037fefcdb68561fd4f87bce61e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa961f037fefcdb68561fd4f87bce61e0">handshake</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target)</td></tr>
<tr class="separator:aa961f037fefcdb68561fd4f87bce61e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84938157b663ea82f8b2856da2880f5"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator &gt; </td></tr>
<tr class="memitem:ac84938157b663ea82f8b2856da2880f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac84938157b663ea82f8b2856da2880f5">handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator)</td></tr>
<tr class="separator:ac84938157b663ea82f8b2856da2880f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bf14b90585d862545407746bfb5d866"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator &gt; </td></tr>
<tr class="memitem:a3bf14b90585d862545407746bfb5d866"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3bf14b90585d862545407746bfb5d866">handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator)</td></tr>
<tr class="separator:a3bf14b90585d862545407746bfb5d866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab955f7b84fac6e0b3616ee0a1d46b60f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab955f7b84fac6e0b3616ee0a1d46b60f">handshake</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ab955f7b84fac6e0b3616ee0a1d46b60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2f33ac431c583ed61ab9aedc9a3d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aba2f33ac431c583ed61ab9aedc9a3d56">handshake</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:aba2f33ac431c583ed61ab9aedc9a3d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5bd76bf23d0d9175cdd682041db9c77"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator &gt; </td></tr>
<tr class="memitem:aa5bd76bf23d0d9175cdd682041db9c77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa5bd76bf23d0d9175cdd682041db9c77">handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:aa5bd76bf23d0d9175cdd682041db9c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78164942869ea3188233242cd3fc134"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator &gt; </td></tr>
<tr class="memitem:ae78164942869ea3188233242cd3fc134"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae78164942869ea3188233242cd3fc134">handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ae78164942869ea3188233242cd3fc134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e5c0aaed02f4ebfe60e41e3aa4544e0"><td class="memTemplParams" colspan="2">template&lt;class HandshakeHandler &gt; </td></tr>
<tr class="memitem:a2e5c0aaed02f4ebfe60e41e3aa4544e0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2e5c0aaed02f4ebfe60e41e3aa4544e0">async_handshake</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, HandshakeHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a2e5c0aaed02f4ebfe60e41e3aa4544e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac67a7ed57ee6f232b848cc79e915eed4"><td class="memTemplParams" colspan="2">template&lt;class HandshakeHandler &gt; </td></tr>
<tr class="memitem:ac67a7ed57ee6f232b848cc79e915eed4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac67a7ed57ee6f232b848cc79e915eed4">async_handshake</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, HandshakeHandler &amp;&amp;handler)</td></tr>
<tr class="separator:ac67a7ed57ee6f232b848cc79e915eed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a0fbaffdd25dc9389e096b25efd69cc"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator , class HandshakeHandler &gt; </td></tr>
<tr class="memitem:a4a0fbaffdd25dc9389e096b25efd69cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a4a0fbaffdd25dc9389e096b25efd69cc">async_handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator, HandshakeHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a4a0fbaffdd25dc9389e096b25efd69cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b3438a536c541a1384812cb7ed840e"><td class="memTemplParams" colspan="2">template&lt;class RequestDecorator , class HandshakeHandler &gt; </td></tr>
<tr class="memitem:a60b3438a536c541a1384812cb7ed840e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a60b3438a536c541a1384812cb7ed840e">async_handshake_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;res, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> host, <a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> target, RequestDecorator const &amp;decorator, HandshakeHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a60b3438a536c541a1384812cb7ed840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825357ae0a6861a7ba82bb32e24ebd31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> ()</td></tr>
<tr class="separator:a825357ae0a6861a7ba82bb32e24ebd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcded0ef580e06f864898ab1c2fa28e4"><td class="memTemplParams" colspan="2">template&lt;class ResponseDecorator &gt; </td></tr>
<tr class="memitem:adcded0ef580e06f864898ab1c2fa28e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#adcded0ef580e06f864898ab1c2fa28e4">accept_ex</a> (ResponseDecorator const &amp;decorator)</td></tr>
<tr class="separator:adcded0ef580e06f864898ab1c2fa28e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae023aa93f013f8ae290be76809f62b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae023aa93f013f8ae290be76809f62b1f">accept</a> (<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ae023aa93f013f8ae290be76809f62b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724ed36195b4e6c592cf066761ed4895"><td class="memTemplParams" colspan="2">template&lt;class ResponseDecorator &gt; </td></tr>
<tr class="memitem:a724ed36195b4e6c592cf066761ed4895"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a724ed36195b4e6c592cf066761ed4895">accept_ex</a> (ResponseDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a724ed36195b4e6c592cf066761ed4895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57c68ac7a9133add9e3754c62bd7b2e"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ae57c68ac7a9133add9e3754c62bd7b2e"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ae57c68ac7a9133add9e3754c62bd7b2e">accept</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:ae57c68ac7a9133add9e3754c62bd7b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23040b0cc6388d8a69c2a6727b010464"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:a23040b0cc6388d8a69c2a6727b010464"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a23040b0cc6388d8a69c2a6727b010464">accept_ex</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator)</td></tr>
<tr class="separator:a23040b0cc6388d8a69c2a6727b010464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01380c2cad25281f6d127389060a3d73"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a01380c2cad25281f6d127389060a3d73"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a01380c2cad25281f6d127389060a3d73">accept</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a01380c2cad25281f6d127389060a3d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af956549842c5ea52ca5d66b281820197"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:af956549842c5ea52ca5d66b281820197"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af956549842c5ea52ca5d66b281820197">accept_ex</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af956549842c5ea52ca5d66b281820197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab453c6bb225c018d685c03f5e8ac00e8"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator &gt; </td></tr>
<tr class="memitem:ab453c6bb225c018d685c03f5e8ac00e8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab453c6bb225c018d685c03f5e8ac00e8">accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req)</td></tr>
<tr class="separator:ab453c6bb225c018d685c03f5e8ac00e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a9d09562467b52b66682b08be5ec63"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:aa7a9d09562467b52b66682b08be5ec63"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa7a9d09562467b52b66682b08be5ec63">accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ResponseDecorator const &amp;decorator)</td></tr>
<tr class="separator:aa7a9d09562467b52b66682b08be5ec63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6deec96ea1210468139d379ee1c774d4"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator &gt; </td></tr>
<tr class="memitem:a6deec96ea1210468139d379ee1c774d4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6deec96ea1210468139d379ee1c774d4">accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a6deec96ea1210468139d379ee1c774d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ca2c5f87acc90b743d9e474c2aa01f"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:a65ca2c5f87acc90b743d9e474c2aa01f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a65ca2c5f87acc90b743d9e474c2aa01f">accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ResponseDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a65ca2c5f87acc90b743d9e474c2aa01f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4677a6bb3fdf236c83a47fa903de8f4"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ac4677a6bb3fdf236c83a47fa903de8f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac4677a6bb3fdf236c83a47fa903de8f4">accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:ac4677a6bb3fdf236c83a47fa903de8f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43064908fb6130087a577d9785035a74"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:a43064908fb6130087a577d9785035a74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a43064908fb6130087a577d9785035a74">accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator)</td></tr>
<tr class="separator:a43064908fb6130087a577d9785035a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209b592d63f62029f20ce48127c4a3cb"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a209b592d63f62029f20ce48127c4a3cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a209b592d63f62029f20ce48127c4a3cb">accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a209b592d63f62029f20ce48127c4a3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c461eedc7ce71f12fb4d239061c677"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator &gt; </td></tr>
<tr class="memitem:a69c461eedc7ce71f12fb4d239061c677"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a69c461eedc7ce71f12fb4d239061c677">accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a69c461eedc7ce71f12fb4d239061c677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafadf51c9b1d80f219a1213088858d00"><td class="memTemplParams" colspan="2">template&lt;class AcceptHandler &gt; </td></tr>
<tr class="memitem:aafadf51c9b1d80f219a1213088858d00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> (AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:aafadf51c9b1d80f219a1213088858d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c51edbbde7d3602ff69d52473b08d49"><td class="memTemplParams" colspan="2">template&lt;class ResponseDecorator , class AcceptHandler &gt; </td></tr>
<tr class="memitem:a9c51edbbde7d3602ff69d52473b08d49"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a9c51edbbde7d3602ff69d52473b08d49">async_accept_ex</a> (ResponseDecorator const &amp;decorator, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a9c51edbbde7d3602ff69d52473b08d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d5a38d3f5de29e599e8bf70513feec"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class AcceptHandler &gt; </td></tr>
<tr class="memitem:a15d5a38d3f5de29e599e8bf70513feec"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value, <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a15d5a38d3f5de29e599e8bf70513feec">async_accept</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a15d5a38d3f5de29e599e8bf70513feec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885e95404d88359fb20f676a44d0de69"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class ResponseDecorator , class AcceptHandler &gt; </td></tr>
<tr class="memitem:a885e95404d88359fb20f676a44d0de69"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; !<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value, <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a885e95404d88359fb20f676a44d0de69">async_accept_ex</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a885e95404d88359fb20f676a44d0de69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55d39ce08fa66056204d9c70b1d5c0c"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class AcceptHandler &gt; </td></tr>
<tr class="memitem:ad55d39ce08fa66056204d9c70b1d5c0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad55d39ce08fa66056204d9c70b1d5c0c">async_accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:ad55d39ce08fa66056204d9c70b1d5c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a201327b65466cd7872859dee27a8"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ResponseDecorator , class AcceptHandler &gt; </td></tr>
<tr class="memitem:a631a201327b65466cd7872859dee27a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a631a201327b65466cd7872859dee27a8">async_accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ResponseDecorator const &amp;decorator, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a631a201327b65466cd7872859dee27a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8259141fea542c9354146aae4e0eaa1e"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence , class AcceptHandler &gt; </td></tr>
<tr class="memitem:a8259141fea542c9354146aae4e0eaa1e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8259141fea542c9354146aae4e0eaa1e">async_accept</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a8259141fea542c9354146aae4e0eaa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56c788b77c92f32a0aac65ce3e6f90c"><td class="memTemplParams" colspan="2">template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator , class AcceptHandler &gt; </td></tr>
<tr class="memitem:ab56c788b77c92f32a0aac65ce3e6f90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab56c788b77c92f32a0aac65ce3e6f90c">async_accept_ex</a> (<a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;req, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ResponseDecorator const &amp;decorator, AcceptHandler &amp;&amp;handler)</td></tr>
<tr class="separator:ab56c788b77c92f32a0aac65ce3e6f90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a052ced8a3f5080d503884a7269330c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8a052ced8a3f5080d503884a7269330c">close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr)</td></tr>
<tr class="separator:a8a052ced8a3f5080d503884a7269330c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651a52f10414e96533eeaac9fe4ba116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a651a52f10414e96533eeaac9fe4ba116">close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a651a52f10414e96533eeaac9fe4ba116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec74c7d9eb8ae1e5b3b7d0ca42401a9"><td class="memTemplParams" colspan="2">template&lt;class CloseHandler &gt; </td></tr>
<tr class="memitem:aaec74c7d9eb8ae1e5b3b7d0ca42401a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; CloseHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">async_close</a> (<a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;cr, CloseHandler &amp;&amp;handler)</td></tr>
<tr class="separator:aaec74c7d9eb8ae1e5b3b7d0ca42401a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d624c21e58f14faa7583bfb69dd143"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a36d624c21e58f14faa7583bfb69dd143">ping</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload)</td></tr>
<tr class="separator:a36d624c21e58f14faa7583bfb69dd143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9035f6c232ab43a98593048c6f29f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a9f9035f6c232ab43a98593048c6f29f7">ping</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a9f9035f6c232ab43a98593048c6f29f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c2ef2165f90ddef92cd599c52d9f61"><td class="memTemplParams" colspan="2">template&lt;class WriteHandler &gt; </td></tr>
<tr class="memitem:a37c2ef2165f90ddef92cd599c52d9f61"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a37c2ef2165f90ddef92cd599c52d9f61">async_ping</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a37c2ef2165f90ddef92cd599c52d9f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4d6fbd19cee706365ac3c94cf37dc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aff4d6fbd19cee706365ac3c94cf37dc6">pong</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload)</td></tr>
<tr class="separator:aff4d6fbd19cee706365ac3c94cf37dc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a8584b8f7709f04d3e7ffa7895d1068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3a8584b8f7709f04d3e7ffa7895d1068">pong</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a3a8584b8f7709f04d3e7ffa7895d1068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da9f92f7884b7898a101a6ecb03542d"><td class="memTemplParams" colspan="2">template&lt;class WriteHandler &gt; </td></tr>
<tr class="memitem:a0da9f92f7884b7898a101a6ecb03542d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0da9f92f7884b7898a101a6ecb03542d">async_pong</a> (<a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;payload, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a0da9f92f7884b7898a101a6ecb03542d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02425e75fcb9db5338f3ec9a901bafc1"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:a02425e75fcb9db5338f3ec9a901bafc1"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a02425e75fcb9db5338f3ec9a901bafc1">read</a> (DynamicBuffer &amp;buffer)</td></tr>
<tr class="separator:a02425e75fcb9db5338f3ec9a901bafc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac419078f45d42c16ece1229bb28308b0"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:ac419078f45d42c16ece1229bb28308b0"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ac419078f45d42c16ece1229bb28308b0">read</a> (DynamicBuffer &amp;buffer, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ac419078f45d42c16ece1229bb28308b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a97ce16733cc7ed1d7be35e8270858"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , class ReadHandler &gt; </td></tr>
<tr class="memitem:a20a97ce16733cc7ed1d7be35e8270858"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a20a97ce16733cc7ed1d7be35e8270858">async_read</a> (DynamicBuffer &amp;buffer, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a20a97ce16733cc7ed1d7be35e8270858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab6df168589e4ad1d7cd83034b8183c8"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:aab6df168589e4ad1d7cd83034b8183c8"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab6df168589e4ad1d7cd83034b8183c8">read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit)</td></tr>
<tr class="separator:aab6df168589e4ad1d7cd83034b8183c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d67260f4b79daea04006ac91e47f26"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer &gt; </td></tr>
<tr class="memitem:a74d67260f4b79daea04006ac91e47f26"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a74d67260f4b79daea04006ac91e47f26">read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a74d67260f4b79daea04006ac91e47f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe643f0c78e5f20229616c88b06d91"><td class="memTemplParams" colspan="2">template&lt;class DynamicBuffer , class ReadHandler &gt; </td></tr>
<tr class="memitem:a6dbe643f0c78e5f20229616c88b06d91"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6dbe643f0c78e5f20229616c88b06d91">async_read_some</a> (DynamicBuffer &amp;buffer, std::size_t limit, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a6dbe643f0c78e5f20229616c88b06d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0dda9a1938d6cd34b060056559beb3"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:aba0dda9a1938d6cd34b060056559beb3"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aba0dda9a1938d6cd34b060056559beb3">read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:aba0dda9a1938d6cd34b060056559beb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d46ce959ce7c56f6711c0eefa006c6f"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence &gt; </td></tr>
<tr class="memitem:a8d46ce959ce7c56f6711c0eefa006c6f"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a8d46ce959ce7c56f6711c0eefa006c6f">read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:a8d46ce959ce7c56f6711c0eefa006c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39916c9e612b5000ccd8d57e3a830d27"><td class="memTemplParams" colspan="2">template&lt;class MutableBufferSequence , class ReadHandler &gt; </td></tr>
<tr class="memitem:a39916c9e612b5000ccd8d57e3a830d27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a39916c9e612b5000ccd8d57e3a830d27">async_read_some</a> (MutableBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, ReadHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a39916c9e612b5000ccd8d57e3a830d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a6ef1d4c11daadc6f17da4cd801c7"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:a761a6ef1d4c11daadc6f17da4cd801c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a761a6ef1d4c11daadc6f17da4cd801c7">write</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:a761a6ef1d4c11daadc6f17da4cd801c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f83527e4d8685de0bd066d4c87f099"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ad4f83527e4d8685de0bd066d4c87f099"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad4f83527e4d8685de0bd066d4c87f099">write</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:ad4f83527e4d8685de0bd066d4c87f099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba8843e0d75cb95392f36d026741032"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class WriteHandler &gt; </td></tr>
<tr class="memitem:a5ba8843e0d75cb95392f36d026741032"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5ba8843e0d75cb95392f36d026741032">async_write</a> (ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a5ba8843e0d75cb95392f36d026741032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3afdc8e68406936eea62138590815c8"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:ab3afdc8e68406936eea62138590815c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab3afdc8e68406936eea62138590815c8">write_some</a> (bool fin, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>)</td></tr>
<tr class="separator:ab3afdc8e68406936eea62138590815c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03e88f22613ae4fcf9e4e8071fcdf7d"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence &gt; </td></tr>
<tr class="memitem:af03e88f22613ae4fcf9e4e8071fcdf7d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#af03e88f22613ae4fcf9e4e8071fcdf7d">write_some</a> (bool fin, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, <a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;ec)</td></tr>
<tr class="separator:af03e88f22613ae4fcf9e4e8071fcdf7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2867311bbdf791acefea89f6568e91c4"><td class="memTemplParams" colspan="2">template&lt;class ConstBufferSequence , class WriteHandler &gt; </td></tr>
<tr class="memitem:a2867311bbdf791acefea89f6568e91c4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2867311bbdf791acefea89f6568e91c4">async_write_some</a> (bool fin, ConstBufferSequence const &amp;<a class="el" href="namespaceboost_1_1beast.html#a3a622817d1bdd0133835e358c37ebda7">buffers</a>, WriteHandler &amp;&amp;handler)</td></tr>
<tr class="separator:a2867311bbdf791acefea89f6568e91c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9095eef7d6ed640e30ae2add0e267583"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a9095eef7d6ed640e30ae2add0e267583">detail::frame_test</a></td></tr>
<tr class="separator:a9095eef7d6ed640e30ae2add0e267583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa435e3810b5c6dc9008ee5fe2df01abd"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa435e3810b5c6dc9008ee5fe2df01abd">stream_test</a></td></tr>
<tr class="separator:aa435e3810b5c6dc9008ee5fe2df01abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70fd38b759202d7d18632bb8b6d8227"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aa70fd38b759202d7d18632bb8b6d8227">frame_test</a></td></tr>
<tr class="separator:aa70fd38b759202d7d18632bb8b6d8227"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class NextLayer&gt;<br />
class boost::beast::websocket::stream&lt; NextLayer &gt;</h3>

<p>Provides message-oriented functionality using WebSocket.</p>
<p>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> class template provides asynchronous and blocking message-oriented functionality necessary for clients and servers to utilize the WebSocket protocol.</p>
<p>For asynchronous operations, the application must ensure that they are are all performed within the same implicit or explicit strand.</p>
<dl class="section user"><dt>Thread Safety</dt><dd><em>Distinct</em> <em>objects:</em> Safe.<br />
<em>Shared</em> <em>objects:</em> Unsafe.</dd></dl>
<dl class="section user"><dt>Example</dt><dd></dd></dl>
<p>To use the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> template with an <code>ip::tcp::socket</code>, you would write:</p>
<div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div></div><!-- fragment --><p> Alternatively, you can write: </p><div class="fragment"><div class="line">ip::tcp::socket sock{io_service};</div><div class="line">websocket::stream&lt;ip::tcp::socket&amp;&gt; ws{sock};</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NextLayer</td><td>The type representing the next layer, to which data will be read and written during operations. For synchronous operations, the type must support the <b>SyncStream</b> concept. For asynchronous operations, the type must support the <b>AsyncStream</b> concept.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A stream object must not be moved or destroyed while there are pending asynchronous operations associated with it.</dd></dl>
<dl class="section user"><dt>Concepts</dt><dd><b>AsyncStream</b>, <b>DynamicBuffer</b>, <b>SyncStream</b> </dd></dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab6118df5dd6f1bdb4adfd10886ce6b3d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a> =  typename <a class="el" href="structboost_1_1beast_1_1get__lowest__layer.html">get_lowest_layer</a>&lt;<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the lowest layer. </p>

</div>
</div>
<a class="anchor" id="aab063b550f536e3c0d16c409cdaf2da4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> =  typename std::remove_reference&lt;NextLayer&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of the next layer. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a140a6d95423fe52f2d18a95391b3d740"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::~<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>Destroys the stream and all associated resources.</p>
<dl class="section note"><dt>Note</dt><dd>A stream object must not be destroyed while there are pending asynchronous operations associated with it. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b1d62ec245a36fe69aa68a0f1bea191"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a>&lt; NextLayer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>If <code>NextLayer</code> is move constructible, this function will move-construct a new stream from the existing stream.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a75d3990969881f791aa6f724747abd98"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::<a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a> </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor</p>
<p>This constructor creates a websocket stream and initializes the next layer object.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">Any</td><td>exceptions thrown by the NextLayer constructor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The arguments to be passed to initialize the next layer object. The arguments are forwarded to the next layer's constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a825357ae0a6861a7ba82bb32e24ebd31"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae023aa93f013f8ae290be76809f62b1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae57c68ac7a9133add9e3754c62bd7b2e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a01380c2cad25281f6d127389060a3d73"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab453c6bb225c018d685c03f5e8ac00e8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6deec96ea1210468139d379ee1c774d4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac4677a6bb3fdf236c83a47fa903de8f4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This must not include the octets corresponding to the HTTP Upgrade request. The implementation will copy the caller provided data before the function returns.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a209b592d63f62029f20ce48127c4a3cb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This must not include the octets corresponding to the HTTP Upgrade request. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adcded0ef580e06f864898ab1c2fa28e4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a724ed36195b4e6c592cf066761ed4895"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a23040b0cc6388d8a69c2a6727b010464"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af956549842c5ea52ca5d66b281820197"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt;!<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and respond to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to synchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa7a9d09562467b52b66682b08be5ec63"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a65ca2c5f87acc90b743d9e474c2aa01f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a43064908fb6130087a577d9785035a74"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This must not include the octets corresponding to the HTTP Upgrade request. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69c461eedc7ce71f12fb4d239061c677"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Respond to a WebSocket HTTP Upgrade request</p>
<p>This function is used to synchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When this call returns, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This must not include the octets corresponding to the HTTP Upgrade request. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aafadf51c9b1d80f219a1213088858d00"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start reading and responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other asynchronous operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a15d5a38d3f5de29e599e8bf70513feec"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value, <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start reading and responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other asynchronous operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad55d39ce08fa66056204d9c70b1d5c0c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8259141fea542c9354146aae4e0eaa1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9c51edbbde7d3602ff69d52473b08d49"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ResponseDecorator , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept_ex </td>
          <td>(</td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start reading and responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other asynchronous operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a885e95404d88359fb20f676a44d0de69"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class ResponseDecorator , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; !<a class="el" href="namespaceboost_1_1beast_1_1http_1_1detail.html#a25c63735f4ae4951c6726007d8085467">http::detail::is_header</a>&lt; ConstBufferSequence &gt;::value, <a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; &gt;::type <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept_ex </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start reading and responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously read an HTTP WebSocket Upgrade request and send the HTTP response. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is received and the response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other asynchronous operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to receive the request. If the request is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to receive larger requests should first read the request using their own buffer and a suitable overload of <a class="el" href="namespaceboost_1_1beast_1_1http.html#ae425f8884c93ad39853e0f254e79eade"><a href="http::read">http::read</a></a> or <a class="el" href="namespaceboost_1_1beast_1_1http.html#a63d24ddb3d0668c1987081ddb997f6a2"><a href="http::async_read">http::async_read</a></a>, then call <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a825357ae0a6861a7ba82bb32e24ebd31">accept</a> or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aafadf51c9b1d80f219a1213088858d00">async_accept</a> with the request.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a631a201327b65466cd7872859dee27a8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ResponseDecorator , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab56c788b77c92f32a0aac65ce3e6f90c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Body , class Allocator , class ConstBufferSequence , class ResponseDecorator , class AcceptHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; AcceptHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_accept_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1http.html#ad10b07a117ed1d74fee4dded03e49437">http::request</a>&lt; Body, <a class="el" href="classboost_1_1beast_1_1http_1_1basic__fields.html">http::basic_fields</a>&lt; Allocator &gt;&gt; const &amp;&#160;</td>
          <td class="paramname"><em>req</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResponseDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AcceptHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start responding to a WebSocket HTTP Upgrade request.</p>
<p>This function is used to asynchronously send the HTTP response to an HTTP request possibly containing a WebSocket Upgrade request. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The response finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>If the stream receives a valid HTTP WebSocket Upgrade request, an HTTP response is sent back indicating a successful upgrade. When the completion handler is invoked, the stream is then ready to send and receive WebSocket protocol frames and messages. If the HTTP Upgrade request is invalid or cannot be satisfied, an HTTP response is sent indicating the reason and status code (typically 400, "Bad Request"). This counts as a failure, and the completion handler will be invoked with a suitable error code set.</p>
<p>The implementation uses fixed size internal storage to copy the buffer. If the buffer is too large, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa0d998bc644f3d7bb85b68137d2bd62c2">error::buffer_overflow</a> will be indicated. Applications that wish to supply larger buffers should wrap the next layer in a <a class="el" href="classboost_1_1beast_1_1buffered__read__stream.html">buffered_read_stream</a> and store the buffer contents in the wrapper before calling accept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>An object containing the HTTP Upgrade request. Ownership is not transferred, the implementation will not access this object from other threads.</td></tr>
    <tr><td class="paramname">buffers</td><td>Caller provided data that has already been received on the stream. This may be used for implementations allowing multiple protocols on the same stream. The buffered data will first be applied to the handshake, and then to received WebSocket frames. The implementation will copy the caller provided data before the function returns.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP response object delivered by the implementation. This could be used to set the Server field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a>&amp; res</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaec74c7d9eb8ae1e5b3b7d0ca42401a9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class CloseHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; CloseHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CloseHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send a WebSocket close frame.</p>
<p>This function is used to asynchronously send a close frame on the stream. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The close frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a37c2ef2165f90ddef92cd599c52d9f61">async_ping</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5ba8843e0d75cb95392f36d026741032">stream::async_write</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2867311bbdf791acefea89f6568e91c4">stream::async_write_some</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">stream::async_close</a>) until this operation completes.</p>
<p>If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</p>
<p>Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> indicates a successful connection closure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the close operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e5c0aaed02f4ebfe60e41e3aa4544e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class HandshakeHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send an upgrade request and receive the response.</p>
<p>This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol. Copies may be made as needed.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac67a7ed57ee6f232b848cc79e915eed4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class HandshakeHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send an upgrade request and receive the response.</p>
<p>This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. The caller must ensure this object is valid for at least until the completion handler is invoked.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol. Copies may be made as needed.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4a0fbaffdd25dc9389e096b25efd69cc"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator , class HandshakeHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send an upgrade request and receive the response.</p>
<p>This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol. Copies may be made as needed.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a60b3438a536c541a1384812cb7ed840e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator , class HandshakeHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; HandshakeHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">HandshakeHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send an upgrade request and receive the response.</p>
<p>This function is used to asynchronously send the HTTP WebSocket upgrade request and receive the HTTP WebSocket Upgrade response. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other operations until this operation completes.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. The caller must ensure this object is valid for at least until the completion handler is invoked.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol. Copies may be made as needed.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol. Copies of this parameter may be made as needed.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the request completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a37c2ef2165f90ddef92cd599c52d9f61"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send a WebSocket ping frame.</p>
<p>This function is used to asynchronously send a ping frame to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:</p>
<ul>
<li>The entire ping frame is sent.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other writes until this operation completes.</p>
<p>If a close frame is sent or received before the ping frame is sent, the completion handler will be called with the error set to <code>boost::asio::error::operation_aborted</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0da9f92f7884b7898a101a6ecb03542d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send a WebSocket pong frame.</p>
<p>This function is used to asynchronously send a pong frame to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:</p>
<ul>
<li>The entire pong frame is sent.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other writes until this operation completes.</p>
<p>The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.</p>
<p>If a close frame is sent or received before the pong frame is sent, the completion handler will be called with the error set to <code>boost::asio::error::operation_aborted</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a20a97ce16733cc7ed1d7be35e8270858"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , class ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a message asynchronously</p>
<p>This function is used to asynchronously read a complete message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other reads until this operation completes.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<p>Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">async_close</a> counts as a write).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied. This object must remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div><div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes appended to buffer</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6dbe643f0c78e5f20229616c88b06d91"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , class ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message asynchronously</p>
<p>This function is used to asynchronously read part of a message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other reads until this operation completes.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<p>Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">async_close</a> counts as a write).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied. This object must remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div><div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes appended to buffer</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39916c9e612b5000ccd8d57e3a830d27"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence , class ReadHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; ReadHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>, std::size_t)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReadHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message asynchronously</p>
<p>This function is used to asynchronously read part of a message from the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_read_some</code> and <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other reads until this operation completes.</p>
<p>Received message data, if any, is written to the buffer sequence. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<p>Because of the need to handle control frames, asynchronous read operations can cause writes to take place. These writes are managed transparently; callers can still have one active asynchronous read and asynchronous write operation pending simultaneously (a user initiated call to <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">async_close</a> counts as a write).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffer sequence into which message data will be placed after any masking or decompresison has been applied. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by the buffer sequence remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the read operation completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec,       <span class="comment">// Result of operation</span></div><div class="line">    std::size_t bytes_written   <span class="comment">// Number of bytes written to the buffer sequence</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5ba8843e0d75cb95392f36d026741032"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to write a message to the stream.</p>
<p>This function is used to asynchronously write a message to the stream. The function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The entire message is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The program must ensure that the stream performs no other write operations (such as <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5ba8843e0d75cb95392f36d026741032">stream::async_write</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2867311bbdf791acefea89f6568e91c4">stream::async_write_some</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">stream::async_close</a>).</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a99b34aa1feb4bddf99490b0383c78cc5">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write operation completes. Copies will be made of the handler as required. The function signature of the handler must be: <div class="fragment"><div class="line"><span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec     <span class="comment">// Result of operation</span></div><div class="line">);</div></div><!-- fragment --> Regardless of whether the asynchronous operation completes immediately or not, the handler will not be invoked from within this function. Invocation of the handler will be performed in a manner equivalent to using <code>boost::asio::io_service::post</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2867311bbdf791acefea89f6568e91c4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence , class WriteHandler &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceboost_1_1beast.html#a3e0a21d8d91f2c30be4d3dd8e796452c">async_return_type</a>&lt; WriteHandler, void(<a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a>)&gt; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::async_write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WriteHandler &amp;&amp;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start an asynchronous operation to send a message frame on the stream.</p>
<p>This function is used to asynchronously write a message frame on the stream. This function call always returns immediately. The asynchronous operation will continue until one of the following conditions is true:</p>
<ul>
<li>The entire frame is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>async_write_some</code> functions, and is known as a <em>composed operation</em>. The actual payload sent may be transformed as per the WebSocket protocol settings. The program must ensure that the stream performs no other write operations (such as <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a5ba8843e0d75cb95392f36d026741032">stream::async_write</a>, <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a2867311bbdf791acefea89f6568e91c4">stream::async_write_some</a>, or <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aaec74c7d9eb8ae1e5b3b7d0ca42401a9">stream::async_close</a>).</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td>A bool indicating whether or not the frame is the last frame in the corresponding WebSockets message.</td></tr>
    <tr><td class="paramname">buffers</td><td>A object meeting the requirements of ConstBufferSequence which holds the payload data before any masking or compression. Although the buffers object may be copied as necessary, ownership of the underlying buffers is retained by the caller, which must guarantee that they remain valid until the handler is called.</td></tr>
    <tr><td class="paramname">handler</td><td>The handler to be called when the write completes. Copies will be made of the handler as required. The equivalent function signature of the handler must be: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> handler(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> <span class="keyword">const</span>&amp; ec    <span class="comment">// Result of operation</span></div><div class="line">); </div></div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a99b34aa1feb4bddf99490b0383c78cc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::auto_fragment </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the automatic fragmentation option.</p>
<p>Determines if outgoing message payloads are broken up into multiple pieces.</p>
<p>When the automatic fragmentation size is turned on, outgoing message payloads are broken up into multiple frames no larger than the write buffer size.</p>
<p>The default setting is to fragment messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>A <code>bool</code> indicating if auto fragmentation should be on.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the automatic fragmentation option: <div class="fragment"><div class="line">ws.auto_fragment(<span class="keyword">true</span>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a5017428f6852bbace4b0b2bc672577c1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::auto_fragment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the automatic fragmentation option is set. </p>

</div>
</div>
<a class="anchor" id="a3dd8bbab79019ecc97dc9b67bf5a120a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::binary </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the binary message option.</p>
<p>This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.</p>
<p>The default setting is to send text messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if outgoing messages should indicate binary, or <code>false</code> if they should indicate text.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the message type to binary. <div class="fragment"><div class="line">ws.binary(<span class="keyword">true</span>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a2c0fc0ba9ddbea98a3b4e02c298d3f46"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the binary message option is set. </p>

</div>
</div>
<a class="anchor" id="a8a052ced8a3f5080d503884a7269330c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket close frame.</p>
<p>This function is used to synchronously send a close frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The close frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<p>If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</p>
<p>Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> indicates a successful connection closure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a651a52f10414e96533eeaac9fe4ba116"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const &amp;&#160;</td>
          <td class="paramname"><em>cr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket close frame.</p>
<p>This function is used to synchronously send a close frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The close frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<p>If the close reason specifies a close code other than beast::websocket::close_code::none, the close frame is sent with the close code and optional reason string. Otherwise, the close frame is sent with no payload.</p>
<p>Callers should not attempt to write WebSocket data after initiating the close. Instead, callers should continue reading until an error occurs. A read returning <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> indicates a successful connection closure.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cr</td><td>The reason for the close.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7e1b674c997a6a86b36ea5c467ae449f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class Callback &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::control_callback </td>
          <td>(</td>
          <td class="paramtype">Callback &amp;&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set a callback to be invoked on each incoming control frame.</p>
<p>Sets the callback to be invoked whenever a ping, pong, or close control frame is received during a call to one of the following functions:</p>
<ul>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a02425e75fcb9db5338f3ec9a901bafc1">beast::websocket::stream::read</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab6df168589e4ad1d7cd83034b8183c8">beast::websocket::stream::read_some</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a20a97ce16733cc7ed1d7be35e8270858">beast::websocket::stream::async_read</a> </li>
<li><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a6dbe643f0c78e5f20229616c88b06d91">beast::websocket::stream::async_read_some</a></li>
</ul>
<p>Unlike completion handlers, the callback will be invoked for each control frame during a call to any synchronous or asynchronous read function. The operation is passive, with no associated error code, and triggered by reads.</p>
<p>For close frames, the close reason code may be obtained by calling the function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3547029823ff37f30e71aaf25c87da3f">reason</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cb</td><td>The function object to call, which must be invocable with this equivalent signature: <div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">callback(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a3138ad00228aa8d4abd2c17c5e494e1e">frame_type</a> kind,       <span class="comment">// The type of frame</span></div><div class="line">    <a class="code" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a> payload    <span class="comment">// The payload in the frame</span></div><div class="line">);</div></div><!-- fragment --> The implementation type-erases the callback without requiring a dynamic allocation. For this reason, the callback object is passed by a non-constant reference. If the read operation which receives the control frame is an asynchronous operation, the callback will be invoked using the same method as that used to invoke the final handler.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>It is not necessary to send a close frame upon receipt of a close frame. The implementation does this automatically. Attempting to send a close frame after a close frame is received will result in undefined behavior. </dd></dl>

</div>
</div>
<a class="anchor" id="ade292bb6341560a9386a8b06a3db7062"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::control_callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the control frame callback.</p>
<p>This function removes any previously set control frame callback. </p>

</div>
</div>
<a class="anchor" id="a5d10d0babb037694e781e3f45cbe7dae"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::asio::io_service&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::get_io_service </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <code>io_service</code> associated with the stream</p>
<p>This function may be used to obtain the <code>io_service</code> object that the stream uses to dispatch handlers for asynchronous operations.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the io_service object that the stream will use to dispatch handlers. </dd></dl>

</div>
</div>
<a class="anchor" id="ab088b13a806fac1ede8b104429ca2c95"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::get_option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the permessage-deflate extension options. </p>

</div>
</div>
<a class="anchor" id="a11f1ec62c55d8752564396ffd5797e0d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::got_binary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the latest message data indicates binary.</p>
<p>This function informs the caller of whether the last received message frame represents a message with the binary opcode.</p>
<p>If there is no last message frame, the return value is undefined. </p>

</div>
</div>
<a class="anchor" id="a0a13693e92798fba7eae53f459960b86"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::got_text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <code>true</code> if the latest message data indicates text.</p>
<p>This function informs the caller of whether the last received message frame represents a message with the text opcode.</p>
<p>If there is no last message frame, the return value is undefined. </p>

</div>
</div>
<a class="anchor" id="ac042c1ac78d2cdcfaa2b10c45e9c166b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">try</div><div class="line">{</div><div class="line">    ws.handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(...)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa961f037fefcdb68561fd4f87bce61e0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">try</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> res;</div><div class="line">    ws.handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(...)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ab955f7b84fac6e0b3616ee0a1d46b60f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">error_code ec;</div><div class="line">ws.handshake(host, target, ec);</div><div class="line"><span class="keywordflow">if</span>(ec)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aba2f33ac431c583ed61ab9aedc9a3d56"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint. If <code>ec</code> is set, the returned value is undefined.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">error_code ec;</div><div class="line"><a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> res;</div><div class="line">ws.handshake(res, host, target, ec);</div><div class="line"><span class="keywordflow">if</span>(ec)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ac84938157b663ea82f8b2856da2880f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">try</div><div class="line">{</div><div class="line">    ws.handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div><div class="line">        [](<a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req)</div><div class="line">        {</div><div class="line">            req.set(field::user_agent, <span class="stringliteral">&quot;Beast&quot;</span>);</div><div class="line">        });</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(...)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bf14b90585d862545407746bfb5d866"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">try</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> res;</div><div class="line">    ws.handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div><div class="line">        [](<a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req)</div><div class="line">        {</div><div class="line">            req.set(field::user_agent, <span class="stringliteral">&quot;Beast&quot;</span>);</div><div class="line">        });</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span>(...)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="aa5bd76bf23d0d9175cdd682041db9c77"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">error_code ec;</div><div class="line">ws.handshake(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div><div class="line">    [](<a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req)</div><div class="line">    {</div><div class="line">        req.set(field::user_agent, <span class="stringliteral">&quot;Beast&quot;</span>);</div><div class="line">    },</div><div class="line">    ec);</div><div class="line"><span class="keywordflow">if</span>(ec)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ae78164942869ea3188233242cd3fc134"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class RequestDecorator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::handshake_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> &amp;&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a0d1b90bc7eb00c02839930489cf4adc4">string_view</a>&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RequestDecorator const &amp;&#160;</td>
          <td class="paramname"><em>decorator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an HTTP WebSocket Upgrade request and receive the response.</p>
<p>This function is used to synchronously send the WebSocket upgrade HTTP request. The call blocks until one of the following conditions is true:</p>
<ul>
<li>The request is sent and the response is received.</li>
</ul>
<ul>
<li>An error occurs on the stream</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>The operation is successful if the received HTTP response indicates a successful HTTP Upgrade (represented by a Status-Code of 101, "switching protocols").</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The HTTP Upgrade response returned by the remote endpoint.</td></tr>
    <tr><td class="paramname">host</td><td>The name of the remote host, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">target</td><td>The Request Target, which may not be empty, required by the HTTP protocol.</td></tr>
    <tr><td class="paramname">decorator</td><td>A function object which will be called to modify the HTTP request object generated by the implementation. This could be used to set the User-Agent field, subprotocols, or other application or HTTP specific fields. The object will be called with this equivalent signature: <div class="fragment"><div class="line"> <span class="keywordtype">void</span> decorator(</div><div class="line">    <a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req</div><div class="line">); </div></div><!-- fragment --></td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd><div class="fragment"><div class="line">websocket::stream&lt;ip::tcp::socket&gt; ws{io_service};</div><div class="line">...</div><div class="line">error_code ec;</div><div class="line"><a class="code" href="namespaceboost_1_1beast_1_1websocket.html#afe58b94c1157584e348fa3e662dde936">response_type</a> res;</div><div class="line">ws.handshake(res, <span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;/&quot;</span>,</div><div class="line">    [](<a class="code" href="namespaceboost_1_1beast_1_1websocket.html#a677a9c2d156409aed7b727a0b25bb466">request_type</a>&amp; req)</div><div class="line">    {</div><div class="line">        req.set(field::user_agent, <span class="stringliteral">&quot;Beast&quot;</span>);</div><div class="line">    },</div><div class="line">    ec);</div><div class="line"><span class="keywordflow">if</span>(ec)</div><div class="line">{</div><div class="line">    <span class="comment">// An error occurred.</span></div><div class="line">}</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="ad2686f5f4adcacca7a2f7c4090895cd2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::is_message_done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the last completed read finished the current message. </p>

</div>
</div>
<a class="anchor" id="a34f82c817a53fc8fe6109da1ce89b7de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the lowest layer</p>
<p>This function returns a reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a class="anchor" id="a94b33ccf6b9a4a6db72e230ebb031493"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab6118df5dd6f1bdb4adfd10886ce6b3d">lowest_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::lowest_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the lowest layer</p>
<p>This function returns a reference to the lowest layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the lowest layer in the stack of stream layers. Ownership is not transferred to the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a5420f2bafaadb6fdba002dd889b615e7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a>&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c7f56e10c9ff8105317a87a1cc3f6a6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#aab063b550f536e3c0d16c409cdaf2da4">next_layer_type</a> const&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::next_layer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a reference to the next layer</p>
<p>This function returns a reference to the next layer in a stack of stream layers.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the next layer in the stack of stream layers. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ac639ff02b59da6f2dac2d384571257"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a>&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">stream</a>&lt; NextLayer &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment</p>
<p>If <code>NextLayer</code> is move assignable, this function will move-assign a new stream from the existing stream.</p>
<dl class="section note"><dt>Note</dt><dd>The behavior of move assignment on or from streams with active or pending operations is undefined. </dd></dl>

</div>
</div>
<a class="anchor" id="a36d624c21e58f14faa7583bfb69dd143"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket ping frame.</p>
<p>This function is used to synchronously send a ping frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The ping frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f9035f6c232ab43a98593048c6f29f7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::ping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket ping frame.</p>
<p>This function is used to synchronously send a ping frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The ping frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the ping message, which may be empty.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aff4d6fbd19cee706365ac3c94cf37dc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket pong frame.</p>
<p>This function is used to synchronously send a pong frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The pong frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<p>The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a8584b8f7709f04d3e7ffa7895d1068"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::pong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast_1_1websocket.html#ac676e3eeaf0065fde9c5324374a51b36">ping_data</a> const &amp;&#160;</td>
          <td class="paramname"><em>payload</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send a WebSocket pong frame.</p>
<p>This function is used to synchronously send a pong frame on the stream. The call blocks until one of the following is true:</p>
<ul>
<li>The pong frame finishes sending.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This function is implemented in terms of one or more calls to the next layer's <code>write_some</code> functions.</p>
<p>The WebSocket protocol allows pong frames to be sent from either end at any time. It is not necessary to first receive a ping in order to send a pong. The remote peer may use the receipt of a pong frame as an indication that the connection is not dead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">payload</td><td>The payload of the pong message, which may be empty.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a02425e75fcb9db5338f3ec9a901bafc1"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a message</p>
<p>This function is used to synchronously read a complete message from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac419078f45d42c16ece1229bb28308b0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a message</p>
<p>This function is used to synchronously read a complete message from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>A complete message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa9f932bd02a9737e295ee23a07f9f0b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_message_max </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the maximum incoming message size option.</p>
<p>Sets the largest permissible incoming message size. Message frame fields indicating a size that would bring the total message size over this limit will cause a protocol failure.</p>
<p>The default setting is 16 megabytes. A value of zero indicates a limit of the maximum value of a <code>std::uint64_t</code>.</p>
<dl class="section user"><dt>Example</dt><dd>Setting the maximum read message size. <div class="fragment"><div class="line">ws.read_message_max(65536);</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The limit on the size of incoming messages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8a62ec09983e1489b8fe6c1c694ae23b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_message_max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the maximum incoming message size setting. </p>

</div>
</div>
<a class="anchor" id="a17615771a24bb059f4dea7da584901da"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_size_hint </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>initial_size</em> = <code>+tcp_frame_size</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a suggested maximum buffer size for the next call to read.</p>
<p>This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_size</td><td>A non-zero size representing the caller's desired buffer size for when there is no information which may be used to calculate a more specific value. For example, when reading the first frame header of a message. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ae5dffd3acda5b092151832be0b6ca516"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer , class &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_size_hint </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a suggested maximum buffer size for the next call to read.</p>
<p>This function returns a reasonable upper limit on the number of bytes for the size of the buffer passed in the next call to read. The number is determined by the state of the current frame and whether or not the permessage-deflate extension is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer which will be used for reading. The implementation will query the buffer to obtain the optimum size of a subsequent call to <code>buffer.prepare</code> based on the state of the current frame, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aab6df168589e4ad1d7cd83034b8183c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message</p>
<p>This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a74d67260f4b79daea04006ac91e47f26"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class DynamicBuffer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">DynamicBuffer &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message</p>
<p>This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is appended to the input area of the buffer. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes appended to the buffer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A dynamic buffer to hold the message data after any masking or decompression has been applied.</td></tr>
    <tr><td class="paramname">limit</td><td>An upper limit on the number of bytes this function will append into the buffer. If this value is zero, then a reasonable size will be chosen automatically.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aba0dda9a1938d6cd34b060056559beb3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message</p>
<p>This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is written to the buffer sequence. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes written to the buffer sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence to hold the message data after any masking or decompression has been applied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown to indicate an error. The corresponding error code may be retrieved from the exception object for inspection. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8d46ce959ce7c56f6711c0eefa006c6f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class MutableBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::read_some </td>
          <td>(</td>
          <td class="paramtype">MutableBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read part of a message</p>
<p>This function is used to synchronously read some message data from the stream. The call blocks until one of the following is true:</p>
<ul>
<li>Some or all of the message is received.</li>
</ul>
<ul>
<li>A close frame is received. In this case the error indicated by the function will be <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a>.</li>
</ul>
<ul>
<li>An error occurs on the stream.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>read_some</code> and <code>write_some</code> functions.</p>
<p>Received message data, if any, is written to the buffer sequence. The functions <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a11f1ec62c55d8752564396ffd5797e0d">got_binary</a> and <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a0a13693e92798fba7eae53f459960b86">got_text</a> may be used to query the stream and determine the type of the last received message. The function <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ad2686f5f4adcacca7a2f7c4090895cd2">is_message_done</a> may be called to determine if the message received by the last read operation is complete.</p>
<p>While this operation is active, the implementation will read incoming control frames and handle them automatically as follows:</p>
<ul>
<li>The <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a7e1b674c997a6a86b36ea5c467ae449f">control_callback</a> will be invoked for each control frame.</li>
</ul>
<ul>
<li>For each received ping frame, a pong frame will be automatically sent.</li>
</ul>
<ul>
<li>If a close frame is received, the WebSocket close procedure is performed. In this case, when the function returns, the error <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac">error::closed</a> will be indicated.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>The number of message payload bytes written to the buffer sequence.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>A buffer sequence to hold the message data after any masking or decompression has been applied.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3547029823ff37f30e71aaf25c87da3f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structboost_1_1beast_1_1websocket_1_1close__reason.html">close_reason</a> const&amp; <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::reason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the close reason received from the peer.</p>
<p>This is only valid after a read completes with <a class="el" href="namespaceboost_1_1beast_1_1websocket.html#a14d8b350031b261b16075c122606eb3fa349e686330723975502e9ef4f939a5ac" title="Both sides performed a WebSocket close. ">error::closed</a>. </p>

</div>
</div>
<a class="anchor" id="a1b9b8d70576c22f3768c2503f272259f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::set_option </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structboost_1_1beast_1_1websocket_1_1permessage__deflate.html">permessage_deflate</a> const &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the permessage-deflate extension options. </p>

</div>
</div>
<a class="anchor" id="acb2907a1047f19201a56383304ec0baf"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::text </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the text message option.</p>
<p>This controls whether or not outgoing message opcodes are set to binary or text. The setting is only applied at the start when a caller begins a new message. Changing the opcode after a message is started will only take effect after the current message being sent is complete.</p>
<p>The default setting is to send text messages.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td><code>true</code> if outgoing messages should indicate text, or <code>false</code> if they should indicate binary.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section user"><dt>Example</dt><dd>Setting the message type to text. <div class="fragment"><div class="line">ws.text(<span class="keyword">true</span>);</div></div><!-- fragment --> </dd></dl>

</div>
</div>
<a class="anchor" id="a6d7511b1d1f9e1657d96189d8b85d070"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::text </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the text message option is set. </p>

</div>
</div>
<a class="anchor" id="a761a6ef1d4c11daadc6f17da4cd801c7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a message to the stream.</p>
<p>This function is used to synchronously write a message to the stream. The call blocks until one of the following conditions is met:</p>
<ul>
<li>The entire message is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>write_some</code> function.</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a99b34aa1feb4bddf99490b0383c78cc5">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function always sends an entire message. To send a message in fragments, use <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab3afdc8e68406936eea62138590815c8">write_some</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad4f83527e4d8685de0bd066d4c87f099"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write </td>
          <td>(</td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a message to the stream.</p>
<p>This function is used to synchronously write a message to the stream. The call blocks until one of the following conditions is met:</p>
<ul>
<li>The entire message is sent.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the next layer's <code>write_some</code> function.</p>
<p>The current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option controls whether the message opcode is set to text or binary. If the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a99b34aa1feb4bddf99490b0383c78cc5">auto_fragment</a> option is set, the message will be split into one or more frames as necessary. The actual payload contents sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffers</td><td>The buffers containing the entire message payload. The implementation will make copies of this object as needed, but ownership of the underlying memory is not transferred. The caller is responsible for ensuring that the memory locations pointed to by buffers remains valid until the completion handler is called.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function always sends an entire message. To send a message in fragments, use <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#ab3afdc8e68406936eea62138590815c8">write_some</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a470ba89aa87d3ead769bcdfa3ebab81c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write_buffer_size </td>
          <td>(</td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>amount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the write buffer size option.</p>
<p>Sets the size of the write buffer used by the implementation to send frames. The write buffer is needed when masking payload data in the client role, compressing frames, or auto-fragmenting message data.</p>
<p>Lowering the size of the buffer can decrease the memory requirements for each connection, while increasing the size of the buffer can reduce the number of calls made to the next layer to write data.</p>
<p>The default setting is 4096. The minimum value is 8.</p>
<p>The write buffer size can only be changed when the stream is not open. Undefined behavior results if the option is modified after a successful WebSocket handshake.</p>
<dl class="section user"><dt>Example</dt><dd>Setting the write buffer size. <div class="fragment"><div class="line">ws.write_buffer_size(8192);</div></div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">amount</td><td>The size of the write buffer in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa1b796d75b4a0a9f8d63e2f8e598e7e2"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write_buffer_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the size of the write buffer. </p>

</div>
</div>
<a class="anchor" id="ab3afdc8e68406936eea62138590815c8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write partial message data on the stream.</p>
<p>This function is used to write some or all of a message's payload to the stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>A frame is sent.</li>
</ul>
<ul>
<li>Message data is transferred to the write buffer.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the stream's <code>write_some</code> function.</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td><code>true</code> if this is the last frame in the message.</td></tr>
    <tr><td class="paramname">buffers</td><td>The input buffer sequence holding the data to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes consumed in the input buffers.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">system_error</td><td>Thrown on failure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af03e88f22613ae4fcf9e4e8071fcdf7d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<div class="memtemplate">
template&lt;class ConstBufferSequence &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html">boost::beast::websocket::stream</a>&lt; NextLayer &gt;::write_some </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstBufferSequence const &amp;&#160;</td>
          <td class="paramname"><em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceboost_1_1beast.html#a7a4590ac91d076157e0336480ef6388d">error_code</a> &amp;&#160;</td>
          <td class="paramname"><em>ec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write partial message data on the stream.</p>
<p>This function is used to write some or all of a message's payload to the stream. The call will block until one of the following conditions is true:</p>
<ul>
<li>A frame is sent.</li>
</ul>
<ul>
<li>Message data is transferred to the write buffer.</li>
</ul>
<ul>
<li>An error occurs.</li>
</ul>
<p>This operation is implemented in terms of one or more calls to the stream's <code>write_some</code> function.</p>
<p>If this is the beginning of a new message, the message opcode will be set to text or binary as per the current setting of the <a class="el" href="classboost_1_1beast_1_1websocket_1_1stream.html#a3dd8bbab79019ecc97dc9b67bf5a120a">binary</a> option. The actual payload sent may be transformed as per the WebSocket protocol settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fin</td><td><code>true</code> if this is the last frame in the message.</td></tr>
    <tr><td class="paramname">buffers</td><td>The input buffer sequence holding the data to write.</td></tr>
    <tr><td class="paramname">ec</td><td>Set to indicate what error occurred, if any.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes consumed in the input buffers. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a9095eef7d6ed640e30ae2add0e267583"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class detail::frame_test</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa70fd38b759202d7d18632bb8b6d8227"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class frame_test</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa435e3810b5c6dc9008ee5fe2df01abd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NextLayer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class stream_test</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>3pp/beast/boost/beast/websocket/<a class="el" href="stream_8hpp_source.html">stream.hpp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="accept_8ipp.html">accept.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="close_8ipp.html">close.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="fail_8ipp.html">fail.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="handshake_8ipp.html">handshake.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="ping_8ipp.html">ping.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="websocket_2impl_2read_8ipp.html">read.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="stream_8ipp.html">stream.ipp</a></li>
<li>3pp/beast/boost/beast/websocket/impl/<a class="el" href="websocket_2impl_2write_8ipp.html">write.ipp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
